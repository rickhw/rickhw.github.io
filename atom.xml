<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Complete Think</title>
  
  <subtitle>Thinking, Coding, and Learning.</subtitle>
  <link href="https://rickhw.github.io/atom.xml" rel="self"/>
  
  <link href="https://rickhw.github.io/"/>
  <updated>2026-02-04T00:42:34.974Z</updated>
  <id>https://rickhw.github.io/</id>
  
  <author>
    <name>Rick Hwang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>置頂 - 更新文章</title>
    <link href="https://rickhw.github.io/2035/01/21/Updated/"/>
    <id>https://rickhw.github.io/2035/01/21/Updated/</id>
    <published>2035-01-21T02:30:00.000Z</published>
    <updated>2026-02-04T00:42:34.974Z</updated>
    
    <content type="html"><![CDATA[<p>底下整理 Blog 更新的文章記錄，提供給想知道哪些文章有更動的朋友。</p><table><thead><tr><th>更新時間</th><th align="left">更新方式</th><th align="left">文章標題</th><th align="left">更新說明</th><th align="left">發布時間</th></tr></thead><tbody><tr><td>2026&#x2F;01&#x2F;26</td><td align="left">新增內容</td><td align="left"><a href="/2022/10/15/Management/Problem-Behind-Question/">Problem Behind Question</a></td><td align="left">新增相關連結</td><td align="left">2022&#x2F;10&#x2F;15</td></tr><tr><td>2025&#x2F;12&#x2F;22</td><td align="left">新增內容</td><td align="left"><a href="/2021/08/20/ComputerScience/HTTPS-TLS/">簡介 HTTPS &#x2F; TLS 安全通訊協議</a></td><td align="left">新增 SSH 交握過程</td><td align="left">2021&#x2F;08&#x2F;20</td></tr><tr><td>2024&#x2F;10&#x2F;06</td><td align="left">新增內容</td><td align="left"><a href="/2019/05/30/AWS/Federated-SSO-to-AWS-using-GSuite/">如何用 G Suite 整合 AWS Single Sign-On</a></td><td align="left">紀錄更新憑證的流程</td><td align="left">2019&#x2F;05&#x2F;30</td></tr><tr><td>2024&#x2F;09&#x2F;14</td><td align="left">重構結構</td><td align="left">從 <code>經營管理</code> 中，新增 <code>人才管理</code>、<code>知識管理</code>、<code>溝通</code>、<code>Career</code> 四個 Category，調整文章分類</td><td align="left">新增目錄</td><td align="left"></td></tr><tr><td>2023&#x2F;07&#x2F;01</td><td align="left">新增內容</td><td align="left"><a href="/2020/06/21/Management/Interview-Problems/">面試常見的問題</a></td><td align="left">新增錄影</td><td align="left">2020&#x2F;06&#x2F;21</td></tr><tr><td>2021&#x2F;08&#x2F;21</td><td align="left">更新參照</td><td align="left"><a href="/2015/08/22/Management/Senior-Software-Developer/">資深軟體工程師</a></td><td align="left">新增參考資料</td><td align="left">2015&#x2F;08&#x2F;22</td></tr><tr><td>2021&#x2F;04&#x2F;30</td><td align="left">新增資料</td><td align="left"><a href="/2019/10/30/SQA/Problems-In-Software-Testing/">關於軟體測試，一些觀察到的現象</a></td><td align="left">新增軟體測試管理工具的選擇</td><td align="left">2019&#x2F;10&#x2F;30</td></tr></tbody></table><span id="more"></span><h2 id="2021"><a href="#2021" class="headerlink" title="2021"></a>2021</h2><table><thead><tr><th>更新時間</th><th align="left">更新方式</th><th align="left">文章標題</th><th align="left">發布時間</th></tr></thead><tbody><tr><td>2021&#x2F;08&#x2F;21</td><td align="left">更新參照</td><td align="left"><a href="/2015/08/22/Management/Senior-Software-Developer/">資深軟體工程師</a></td><td align="left">2015&#x2F;08&#x2F;22</td></tr><tr><td>2021&#x2F;04&#x2F;30</td><td align="left">新增資料</td><td align="left"><a href="/2019/10/30/SQA/Problems-In-Software-Testing/">關於軟體測試，一些觀察到的現象</a></td><td align="left">2019&#x2F;10&#x2F;30</td></tr><tr><td>2021&#x2F;04&#x2F;20</td><td align="left">新增資料</td><td align="left"><a href="/2019/03/17/Management/Perspective-in-XYZT/">看見怎樣的全貌 - 軟體開發的三體問題</a></td><td align="left">2019&#x2F;03&#x2F;17</td></tr><tr><td>2021&#x2F;03&#x2F;27</td><td align="left">新增資料</td><td align="left"><a href="/2020/03/07/ComputerScience/Cryptography/">摘要密碼學與資訊安全</a></td><td align="left">2020&#x2F;03&#x2F;07</td></tr></tbody></table><h2 id="2020"><a href="#2020" class="headerlink" title="2020"></a>2020</h2><table><thead><tr><th>更新時間</th><th align="left">更新方式</th><th align="left">文章標題</th><th align="left">發布時間</th></tr></thead><tbody><tr><td>2020&#x2F;09&#x2F;13</td><td align="left">新增資料</td><td align="left"><a href="/2018/06/18/DistributedSystems/Gossip-in-Distributed-Systems/">聊聊分散式系統</a></td><td align="left">2018&#x2F;06&#x2F;18</td></tr><tr><td>2020&#x2F;09&#x2F;13</td><td align="left">增加段落</td><td align="left"><a href="https://rickhw.github.io/2018/08/11/DistributedSystems/CAP-Theorem/">CAP Theorem</a></td><td align="left">2018&#x2F;08&#x2F;11</td></tr><tr><td>2020&#x2F;08&#x2F;09</td><td align="left">調整結構</td><td align="left"><a href="/2019/03/17/Container/Install-K8s-with-Kubeadm/">K8s 學習筆記 - kubeadm 手動安裝</a></td><td align="left">2019&#x2F;03&#x2F;17</td></tr><tr><td>2020&#x2F;07&#x2F;25</td><td align="left">增加段落</td><td align="left"><a href="/2018/08/11/DistributedSystems/Distributed-Consistency-and-Consensus-Algorithm/">一致性問題與共識演算法</a></td><td align="left">2018&#x2F;08&#x2F;11</td></tr><tr><td>2020&#x2F;06&#x2F;07</td><td align="left">增加段落</td><td align="left"><a href="/2017/09/20/About/Learning-Approaches/">學習法則</a></td><td align="left">2017&#x2F;09&#x2F;20</td></tr><tr><td>2020&#x2F;05&#x2F;26</td><td align="left">重構文章</td><td align="left"><a href="/2015/08/22/Management/Senior-Software-Developer/">資深軟體工程師</a></td><td align="left">2015&#x2F;08&#x2F;22</td></tr><tr><td>2020&#x2F;05&#x2F;09</td><td align="left">文句修飾</td><td align="left"><a href="/2019/06/05/DevOps/Github-Incident-Analysis/">GitHub Post-Incident Analysis</a></td><td align="left">2019&#x2F;06&#x2F;05</td></tr><tr><td>2020&#x2F;03&#x2F;22</td><td align="left">重構文章</td><td align="left"><a href="/2019/04/04/AWS/Study-Notes-EC2-Auto-Scaling-FAQ/">Study Notes - EC2 Auto Scaling 常見問題</a></td><td align="left">2019&#x2F;04&#x2F;04</td></tr><tr><td>2020&#x2F;03&#x2F;10</td><td align="left">增加段落</td><td align="left"><a href="/2018/06/08/Management/Naming-for-Products/">你的靈魂 - 談產品名稱的命名</a></td><td align="left">2018&#x2F;06&#x2F;08</td></tr><tr><td>2020&#x2F;03&#x2F;04</td><td align="left">增加段落</td><td align="left"><a href="/2018/10/08/DevOps/Chaos-Engineering/">Chaos Engineering (混沌工程)</a></td><td align="left">2018&#x2F;10&#x2F;08</td></tr><tr><td>2020&#x2F;02&#x2F;29</td><td align="left">增加段落</td><td align="left"><a href="/2020/02/08/Container/Why-Container/">Why Container</a></td><td align="left">2020&#x2F;02&#x2F;08</td></tr><tr><td>2020&#x2F;02&#x2F;08</td><td align="left">增加段落</td><td align="left"><a href="/2016/11/27/AWS/Whitepaper-AWS-Well-Architect-Framework/">Whitepaper - AWS Well-Architected Framework</a></td><td align="left">2016&#x2F;11&#x2F;27</td></tr><tr><td>2020&#x2F;01&#x2F;08</td><td align="left">增加段落</td><td align="left"><a href="/2019/09/09/AWS/Whitepaper-Using-AWS-For-Disaster-Recovery/">Whitepaper - Using AWS for Disaster Recovery</a></td><td align="left">2019&#x2F;09&#x2F;09</td></tr><tr><td>2020&#x2F;01&#x2F;31</td><td align="left">增加資料</td><td align="left"><a href="/2018/06/14/DevOps/Recap-What-is-Ops/">再談啥是維運？</a></td><td align="left">2018&#x2F;06&#x2F;14</td></tr><tr><td>2020&#x2F;01&#x2F;02</td><td align="left">增加段落</td><td align="left"><a href="/2019/10/30/SQA/Problems-In-Software-Testing/">關於軟體測試，一些觀察到的現象</a></td><td align="left">2019&#x2F;10&#x2F;30</td></tr></tbody></table><hr><h2 id="2019-x2F-Q4"><a href="#2019-x2F-Q4" class="headerlink" title="2019&#x2F;Q4"></a>2019&#x2F;Q4</h2><table><thead><tr><th>更新時間</th><th align="left">更新方式</th><th align="left">文章標題</th><th align="left">發布時間</th></tr></thead><tbody><tr><td>2019&#x2F;12&#x2F;15</td><td align="left">重構結構</td><td align="left"><a href="/2017/07/01/Reference/Books/">參考書</a></td><td align="left">2017&#x2F;07&#x2F;01</td></tr><tr><td>2019&#x2F;12&#x2F;13</td><td align="left">增加段落</td><td align="left"><a href="/2016/04/07/AWS/Study-Notes-S3/">Study Notes - AWS S3</a></td><td align="left">2016&#x2F;04&#x2F;07</td></tr><tr><td>2019&#x2F;11&#x2F;16</td><td align="left">重構文章</td><td align="left"><a href="/2016/11/27/AWS/Whitepaper-AWS-Well-Architect-Framework/">Whitepaper - AWS Well-Architected Framework</a></td><td align="left">2016&#x2F;11&#x2F;27</td></tr><tr><td>2019&#x2F;11&#x2F;16</td><td align="left">增加段落</td><td align="left"><a href="/2018/03/18/SQA/How-To-Report-A-Defect-or-Bug/">如何有效的回報問題</a></td><td align="left">2018&#x2F;03&#x2F;18</td></tr><tr><td>2019&#x2F;10&#x2F;16</td><td align="left">增加段落</td><td align="left"><a href="/2017/09/20/About/Learning-Approaches/">學習法則</a></td><td align="left">2017&#x2F;09&#x2F;20</td></tr><tr><td>2019&#x2F;10&#x2F;16</td><td align="left">修改段落</td><td align="left"><a href="/2017/07/15/Container/Experience-minikube/">Experience minikube</a></td><td align="left">2017&#x2F;07&#x2F;15</td></tr><tr><td>2019&#x2F;10&#x2F;14</td><td align="left">增加段落</td><td align="left"><a href="/2019/09/20/SQA/How-to-Measure-System-Capacity/">如何量測系統的容量？</a></td><td align="left">2019&#x2F;09&#x2F;20</td></tr><tr><td>2019&#x2F;10&#x2F;14</td><td align="left">增加段落</td><td align="left"><a href="/2019/04/05/About/Working-Backwards/">一個人的 Working Backwards</a></td><td align="left">2019&#x2F;04&#x2F;05</td></tr><tr><td>2019&#x2F;10&#x2F;13</td><td align="left">增加段落</td><td align="left"><a href="/2018/06/18/DistributedSystems/Gossip-in-Distributed-Systems/">聊聊分散式系統</a></td><td align="left">2018&#x2F;06&#x2F;18</td></tr><tr><td>2019&#x2F;10&#x2F;13</td><td align="left">修改段落</td><td align="left"><a href="/2016/08/17/AWS/Study-Notes-DynamoDB/">DynamoDB 學習筆記</a></td><td align="left">2016&#x2F;08&#x2F;17</td></tr><tr><td>2019&#x2F;10&#x2F;06</td><td align="left">修改段落</td><td align="left"><a href="/2019/03/17/Container/Install-K8s-with-Kubeadm/">K8s 安裝筆記 (ubuntu16.04) - kubeadm 手動</a></td><td align="left">2019&#x2F;03&#x2F;17</td></tr></tbody></table><h2 id="2019-x2F-Q3"><a href="#2019-x2F-Q3" class="headerlink" title="2019&#x2F;Q3"></a>2019&#x2F;Q3</h2><table><thead><tr><th>更新時間</th><th align="left">更新方式</th><th align="left">文章標題</th><th align="left">發布時間</th></tr></thead><tbody><tr><td>2019&#x2F;09&#x2F;10</td><td align="left">增加段落</td><td align="left"><a href="/2018/12/16/DevOps/Hire-a-Release-Engineer/">需要專職的 Release Engineer？</a></td><td align="left">2018&#x2F;12&#x2F;16</td></tr><tr><td>2019&#x2F;09&#x2F;10</td><td align="left">增加段落</td><td align="left"><a href="/2019/01/21/Management/KM-and-Issue-Tracking/">Issue Tracking 在企業裡的價值 - KM</a></td><td align="left">2019&#x2F;01&#x2F;21</td></tr><tr><td>2019&#x2F;09&#x2F;01</td><td align="left">增加段落</td><td align="left"><a href="/2019/01/20/About/Reading/">閱讀能力的重要性</a></td><td align="left">2019&#x2F;01&#x2F;20</td></tr><tr><td>2019&#x2F;08&#x2F;31</td><td align="left">增加段落</td><td align="left"><a href="/2018/09/22/Management/Hiring-Step3-Interview-Values-Attitude/">人力招募 - 三、深度對話：價值觀</a></td><td align="left">2018&#x2F;09&#x2F;22</td></tr><tr><td>2019&#x2F;08&#x2F;20</td><td align="left">重構結構</td><td align="left"><a href="/2019/05/30/AWS/Federated-SSO-to-AWS-using-GSuite/">如何用 G Suite 整合 AWS Single Sign-On</a></td><td align="left">2019&#x2F;05&#x2F;30</td></tr></tbody></table><h2 id="2019-x2F-Q2"><a href="#2019-x2F-Q2" class="headerlink" title="2019&#x2F;Q2"></a>2019&#x2F;Q2</h2><table><thead><tr><th>更新時間</th><th align="left">更新方式</th><th align="left">文章標題</th><th align="left">發布時間</th></tr></thead><tbody><tr><td>2019&#x2F;06&#x2F;11</td><td align="left">重構文章</td><td align="left"><a href="/2016/04/07/AWS/Study-Notes-S3/">Study Notes - AWS S3</a></td><td align="left">2016&#x2F;04&#x2F;07</td></tr><tr><td>2019&#x2F;05&#x2F;31</td><td align="left">增加段落</td><td align="left"><a href="/2014/10/26/Management/Classified-Philosophy/">分類的哲學</a></td><td align="left">2014&#x2F;10&#x2F;26</td></tr><tr><td>2019&#x2F;05&#x2F;31</td><td align="left">增加段落</td><td align="left"><a href="/2017/03/18/SQA/Stages-In-Software-Testing/">淺談軟體測試的階段與策略</a></td><td align="left">2017&#x2F;03&#x2F;18</td></tr><tr><td>2019&#x2F;04&#x2F;07</td><td align="left">重構結構</td><td align="left"><a href="/2016/02/21/AWS/Study-Notes-VPC/">Study Notes - Virtual Private Cloud (VPC)</a></td><td align="left">2016&#x2F;02&#x2F;21</td></tr><tr><td>2019&#x2F;04&#x2F;04</td><td align="left">重構結構</td><td align="left"><a href="/2017/02/04/AWS/Study-Notes-EC2-Auto-Scaling/">Study Notes - EC2 Auto Scaling</a></td><td align="left">2017&#x2F;02&#x2F;04</td></tr><tr><td>2019&#x2F;04&#x2F;04</td><td align="left">調整結構</td><td align="left"><a href="/2017/02/11/DevOps/Resource-Provisioning-and-DevOps/">Resource Provisioning and DevOps</a></td><td align="left">2017&#x2F;02&#x2F;11</td></tr></tbody></table><h2 id="2019-x2F-Q1"><a href="#2019-x2F-Q1" class="headerlink" title="2019&#x2F;Q1"></a>2019&#x2F;Q1</h2><table><thead><tr><th>更新時間</th><th align="left">更新方式</th><th align="left">文章標題</th><th align="left">發布時間</th></tr></thead><tbody><tr><td>2019&#x2F;03&#x2F;23</td><td align="left">增加段落</td><td align="left"><a href="/2018/01/24/DistributedSystems/Overview-API-Gateway/">Overview API Gateway</a></td><td align="left">2018&#x2F;01&#x2F;24</td></tr><tr><td>2019&#x2F;01&#x2F;18</td><td align="left">增加段落</td><td align="left"><a href="/2018/07/08/DevOps/Artifacts-Management/">Artifacts Management</a></td><td align="left">2018&#x2F;07&#x2F;08</td></tr><tr><td>2019&#x2F;01&#x2F;11</td><td align="left">增加段落</td><td align="left"><a href="/2018/04/01/DevOps/How-To-Make-CICD-Quality/">怎樣的 CI&#x2F;CD 才夠 Quality?</a></td><td align="left">2018&#x2F;04&#x2F;01</td></tr><tr><td>2019&#x2F;01&#x2F;06</td><td align="left">重構結構</td><td align="left"><a href="/2017/09/20/About/Learning-Approaches/">學習法則</a></td><td align="left">2017&#x2F;09&#x2F;20</td></tr><tr><td>2019&#x2F;01&#x2F;06</td><td align="left">增加段落</td><td align="left"><a href="/2018/08/20/Management/Overview-Hiring/">聊聊人力招募</a></td><td align="left">2017&#x2F;02&#x2F;04</td></tr><tr><td>2019&#x2F;01&#x2F;06</td><td align="left">文句修飾</td><td align="left"><a href="/2017/11/14/DevOps/Go-Live/">Go Live</a></td><td align="left">2017&#x2F;11&#x2F;14</td></tr><tr><td>2019&#x2F;01&#x2F;05</td><td align="left">文句修飾</td><td align="left"><a href="/2018/12/16/DevOps/Hire-a-Release-Engineer/">需要專職的 Release Engineer？</a></td><td align="left">2018&#x2F;12&#x2F;16</td></tr></tbody></table><hr><h1 id="2018"><a href="#2018" class="headerlink" title="2018"></a>2018</h1><h2 id="2018-x2F-Q4"><a href="#2018-x2F-Q4" class="headerlink" title="2018&#x2F;Q4"></a>2018&#x2F;Q4</h2><table><thead><tr><th>更新時間</th><th align="left">更新方式</th><th align="left">文章標題</th><th align="left">發布時間</th></tr></thead><tbody><tr><td>2018&#x2F;12&#x2F;26</td><td align="left">重構系列文</td><td align="left"><a href="/2017/03/02/AWS/Study-Notes-CloudWatch/">Study Notes - CloudWatch</a></td><td align="left">2017&#x2F;03&#x2F;02</td></tr><tr><td>2018&#x2F;12&#x2F;22</td><td align="left">重構系列文</td><td align="left"><a href="/2017/03/30/AWS/Study-Notes-CloudFormation/">Study Notes - CloudFormation</a></td><td align="left">2017&#x2F;03&#x2F;30</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;底下整理 Blog 更新的文章記錄，提供給想知道哪些文章有更動的朋友。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;更新時間&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;更新方式&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;文章標題&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;更新說明&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;發布時間&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;2026&amp;#x2F;01&amp;#x2F;26&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;新增內容&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;/2022/10/15/Management/Problem-Behind-Question/&quot;&gt;Problem Behind Question&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;新增相關連結&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;2022&amp;#x2F;10&amp;#x2F;15&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2025&amp;#x2F;12&amp;#x2F;22&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;新增內容&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;/2021/08/20/ComputerScience/HTTPS-TLS/&quot;&gt;簡介 HTTPS &amp;#x2F; TLS 安全通訊協議&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;新增 SSH 交握過程&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;2021&amp;#x2F;08&amp;#x2F;20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2024&amp;#x2F;10&amp;#x2F;06&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;新增內容&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;/2019/05/30/AWS/Federated-SSO-to-AWS-using-GSuite/&quot;&gt;如何用 G Suite 整合 AWS Single Sign-On&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;紀錄更新憑證的流程&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;2019&amp;#x2F;05&amp;#x2F;30&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2024&amp;#x2F;09&amp;#x2F;14&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;重構結構&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;從 &lt;code&gt;經營管理&lt;/code&gt; 中，新增 &lt;code&gt;人才管理&lt;/code&gt;、&lt;code&gt;知識管理&lt;/code&gt;、&lt;code&gt;溝通&lt;/code&gt;、&lt;code&gt;Career&lt;/code&gt; 四個 Category，調整文章分類&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;新增目錄&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2023&amp;#x2F;07&amp;#x2F;01&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;新增內容&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;/2020/06/21/Management/Interview-Problems/&quot;&gt;面試常見的問題&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;新增錄影&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;2020&amp;#x2F;06&amp;#x2F;21&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2021&amp;#x2F;08&amp;#x2F;21&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;更新參照&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;/2015/08/22/Management/Senior-Software-Developer/&quot;&gt;資深軟體工程師&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;新增參考資料&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;2015&amp;#x2F;08&amp;#x2F;22&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2021&amp;#x2F;04&amp;#x2F;30&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;新增資料&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;/2019/10/30/SQA/Problems-In-Software-Testing/&quot;&gt;關於軟體測試，一些觀察到的現象&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;新增軟體測試管理工具的選擇&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;2019&amp;#x2F;10&amp;#x2F;30&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>置頂 - 全站索引</title>
    <link href="https://rickhw.github.io/2035/01/21/Index/"/>
    <id>https://rickhw.github.io/2035/01/21/Index/</id>
    <published>2035-01-21T02:30:00.000Z</published>
    <updated>2025-06-27T12:21:44.305Z</updated>
    
    <content type="html"><![CDATA[<p>這篇是整個 Blog 的全站索引，如果您是第一次來這裡，可以先看看這篇索引，大概知道 Blog 的全貌：</p><ul><li>[理念] <a href="/2017/11/26/Thinking-in-Essence/">思考本質、實踐、抽象、想像力、教育</a></li><li>[目錄] <a href="/2017/07/01/Index-Management/">經營管理</a>: 整理管理經驗談、管理哲學、經營、領導、用人之道、學習方法、專案管理</li><li>[目錄] <a href="/2017/07/01/Index-Software-Engineering-In-Practice/">軟體工程實踐</a>: 包含軟體架構、開發、測試、維運等 … 實踐的心得。</li><li>[目錄] <a href="/categories/Distributed-Systems">分散式系統</a>，包含分散式系統理論、Cloud Native - <a href="/tags/Kubernetes/">Kubernetes</a>、<a href="/2016/10/01/AWS-Study-Roadmap/">AWS</a>。</li><li>[參考] <a href="/2017/07/01/Reference/Books/">參考書</a>、<a href="/2017/07/01/Reference/Tech-Terms/">資訊技術與工程專有名詞</a>、<a href="/2017/07/01/Reference/SC-Terms/">計算機科學專有名詞</a>、<a href="/2017/07/01/Reference/Mgmt-Terms/">經營管理專有名詞</a></li><li>[系列文] <a href="/tags/Bus-Memo/">公車隨筆</a>、<a href="/tags/Learning-Approaches/">寫作與閱讀系列文</a>、<a href="/tags/%E6%BA%9D%E9%80%9A/">溝通</a>、<a href="/tags/Meetings/">會議效率</a></li><li>[關於] <a href="/2017/09/20/About/Learning-Approaches/">學習法則</a>、<a href="/2014/12/27/Management/%E7%B6%93%E7%87%9F%E4%B9%8B%E9%81%93/">經營之道</a>、<a href="/2017/12/02/About/Epiphany/">一些領悟</a>、<a href="/2014/10/26/Management/Classified-Philosophy/">分類哲學</a></li><li>[站內記事]: <a href="/2035/01/21/Updated/">文章更新紀錄</a>, <a href="/2013/11/26/Stats/">點閱率統計</a></li></ul><blockquote><p>不管是程式、文章、資料、還是房間，我都會定期重新整理 &#x2F; 重構，核心概念來自於 <a href="/2014/10/26/Management/Classified-Philosophy/">分類的哲學</a></p></blockquote><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;p&gt;這篇是整個 Blog 的全站索引，如果您是第一次來這裡，可以先看看這篇索引，大概知道 Blog 的全貌：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[理念] &lt;a href=&quot;/2017/11/26/Thinking-in-Essence/&quot;&gt;思考本質、實踐、抽象、想像力、教育&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[目錄] &lt;a href=&quot;/2017/07/01/Index-Management/&quot;&gt;經營管理&lt;/a&gt;: 整理管理經驗談、管理哲學、經營、領導、用人之道、學習方法、專案管理&lt;/li&gt;
&lt;li&gt;[目錄] &lt;a href=&quot;/2017/07/01/Index-Software-Engineering-In-Practice/&quot;&gt;軟體工程實踐&lt;/a&gt;: 包含軟體架構、開發、測試、維運等 … 實踐的心得。&lt;/li&gt;
&lt;li&gt;[目錄] &lt;a href=&quot;/categories/Distributed-Systems&quot;&gt;分散式系統&lt;/a&gt;，包含分散式系統理論、Cloud Native - &lt;a href=&quot;/tags/Kubernetes/&quot;&gt;Kubernetes&lt;/a&gt;、&lt;a href=&quot;/2016/10/01/AWS-Study-Roadmap/&quot;&gt;AWS&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;[參考] &lt;a href=&quot;/2017/07/01/Reference/Books/&quot;&gt;參考書&lt;/a&gt;、&lt;a href=&quot;/2017/07/01/Reference/Tech-Terms/&quot;&gt;資訊技術與工程專有名詞&lt;/a&gt;、&lt;a href=&quot;/2017/07/01/Reference/SC-Terms/&quot;&gt;計算機科學專有名詞&lt;/a&gt;、&lt;a href=&quot;/2017/07/01/Reference/Mgmt-Terms/&quot;&gt;經營管理專有名詞&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[系列文] &lt;a href=&quot;/tags/Bus-Memo/&quot;&gt;公車隨筆&lt;/a&gt;、&lt;a href=&quot;/tags/Learning-Approaches/&quot;&gt;寫作與閱讀系列文&lt;/a&gt;、&lt;a href=&quot;/tags/%E6%BA%9D%E9%80%9A/&quot;&gt;溝通&lt;/a&gt;、&lt;a href=&quot;/tags/Meetings/&quot;&gt;會議效率&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[關於] &lt;a href=&quot;/2017/09/20/About/Learning-Approaches/&quot;&gt;學習法則&lt;/a&gt;、&lt;a href=&quot;/2014/12/27/Management/%E7%B6%93%E7%87%9F%E4%B9%8B%E9%81%93/&quot;&gt;經營之道&lt;/a&gt;、&lt;a href=&quot;/2017/12/02/About/Epiphany/&quot;&gt;一些領悟&lt;/a&gt;、&lt;a href=&quot;/2014/10/26/Management/Classified-Philosophy/&quot;&gt;分類哲學&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[站內記事]: &lt;a href=&quot;/2035/01/21/Updated/&quot;&gt;文章更新紀錄&lt;/a&gt;, &lt;a href=&quot;/2013/11/26/Stats/&quot;&gt;點閱率統計&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;不管是程式、文章、資料、還是房間，我都會定期重新整理 &amp;#x2F; 重構，核心概念來自於 &lt;a href=&quot;/2014/10/26/Management/Classified-Philosophy/&quot;&gt;分類的哲學&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Job Description</title>
    <link href="https://rickhw.github.io/2026/01/11/Management/Job-Description/"/>
    <id>https://rickhw.github.io/2026/01/11/Management/Job-Description/</id>
    <published>2026-01-10T16:16:00.000Z</published>
    <updated>2026-01-29T06:21:29.417Z</updated>
    
    <content type="html"><![CDATA[<p><code>Job Description</code>，簡稱 JD，是企業在招人，提供對外招募的資訊，包含 <code>工作內容</code>、以及 <code>職缺條件</code>。</p><p>這篇整理以前在寫 JD 時背後的思路與心得。</p><span id="more"></span><hr><h2 id="以前寫的-JD-紀錄"><a href="#以前寫的-JD-紀錄" class="headerlink" title="以前寫的 JD 紀錄"></a>以前寫的 JD 紀錄</h2><p>整理以前寫過的、有留下來的紀錄，整理如下。當下沒截圖記錄的只能 QQ 了。。。</p><h3 id="SQA-x2F-SDET"><a href="#SQA-x2F-SDET" class="headerlink" title="SQA&#x2F;SDET"></a>SQA&#x2F;SDET</h3><p>下圖這個 JD 約莫是在 2012 年寫的，那時候我的職位是 SQA Manager 和 SDET Lead，當時要找的是 <code>手動測試 Mobile APPs and Web APP</code> 以及 <code>模擬大量 IP Camera 連線到 Streaming Server</code> 的效能測試 工作。</p><blockquote><p>這段故事詳細可以參閱 <a href="/2023/05/23/About/2023-Software-Test-Practice/">共同著作《軟體測試實務 I、II》</a> - 第一冊 CH05 從零開始，軟體測試團隊建立實戰，有詳細的介紹。</p></blockquote><p><img src="/images/Management/Job-Description/20140108-SQA-SDET.png"></p><p>這個 JD 把 SQA&#x2F;SDET 這兩個職務放在一起寫，依照滿足的條件，來決定是 SQA or SDET。這兩個的差異可以參閱我這篇整理：<a href="/2015/10/11/SQA/How-To-Be-An-SQA/">Software QA 的職能條件</a>、<a href="/2022/08/13/SQA/Path-to-Software-Testing/">演講：從理想、到現實的距離，開啟品味軟體測試之路</a></p><h3 id="軟體工程師"><a href="#軟體工程師" class="headerlink" title="軟體工程師"></a>軟體工程師</h3><p>底下這個 JD 大約是 2017 年寫的草稿，後來上人力銀行的沒有截圖，不過原稿有留下。</p><p>那時候我的角色是 MIS &#x2F; Cloud and Infra &#x2F; Service Development Team 的主管。這個主要是要找 Node.JS 的開發者，同時需要具備部分 Cloud 與容器化的潛力。</p><p><img src="/images/Management/Job-Description/2018-JD-Software-Developer.png"></p><p>這個職缺的時空背景 (2015-2020)，AWS 是新顯學，Docker &#x2F; Node.JS 正在火紅，K8s 正在起飛，工作內容則是 <code>通知平台</code> 的設計與開發，要處理每天數千萬筆的 Mobile APP Push (iOS &#x2F; Android)、Email、SMS 等。</p><blockquote><p>相關：<a href="/2017/07/01/Management/Developer-or-Engineer/">Developer, or Engineer</a></p></blockquote><h3 id="Cloud-Engineer-x2F-SRE"><a href="#Cloud-Engineer-x2F-SRE" class="headerlink" title="Cloud Engineer &#x2F; SRE"></a>Cloud Engineer &#x2F; SRE</h3><p>底下這個 JD 截圖也是 2017 年左右寫的。跟上一個算是同期開的職缺，不一樣的是這個位置專注在兩個部分：</p><ol><li>SRE: 就是要透過軟體工程，改善系統維運的工作</li><li>Cloud and Infra Operations: 專注在公有雲上的基礎架構維護，像是 Network &#x2F; Firewall &#x2F; OS &#x2F; Observiblity … etc.</li></ol><p><img src="/images/Management/Job-Description/20190814-91APP.jpg"></p><p>這個職務範圍很廣泛，但是為了避免求職者以為要會很多，所以在工作內容拆分兩個區塊，也是為接下來的職涯做拆分。整體的設計前者是 SRE，也就是具備軟體工程能力的人；後者其實是為了吸引不具備寫 Code，但是是傳統的 MIS &#x2F; Networking 專長的人。最後這兩個還是會一起工作，因為本質內容是一樣的，只是做事方法不一樣而已。</p><blockquote><p>上述職務概念可以參閱：<a href="/2018/03/29/About/2018-Serverless-All-Star/">演講：Serverless All-Star - Ops as Code using Serverless</a> </p></blockquote><hr><h2 id="JD-的規則-以-軟體開發工程師-為例"><a href="#JD-的規則-以-軟體開發工程師-為例" class="headerlink" title="JD 的規則 - 以 軟體開發工程師 為例"></a>JD 的規則 - 以 <code>軟體開發工程師</code> 為例</h2><p>寫 JD 的人，如果沒有做適度的思考，經常會讓求職者覺得要很多、但出不起對等的待遇，然後要找人的主管則會發現過了半年，無人來面試的窘境。</p><p>當時在設計招募策略時，在 JD 的表示，我有自己一套規則，下圖則是當時寫下的規則與背後的考慮：</p><p><img src="/images/Management/Job-Description/2018-Consideration.png"></p><p>這份寫 JD 的規則，出發點是務實，也就是基於理性與務實的角度出發，讓求職者覺得：</p><ol><li>這才是一個人做的來的工作</li><li>雖然做的來，但挑戰還是有的，而且我想試試看</li><li>可以讓求職者感受到，求才若渴的用心</li><li>付出和所得是對等的 </li><li>資方與勞方對等</li></ol><h3 id="Engineer-or-Developer？"><a href="#Engineer-or-Developer？" class="headerlink" title="Engineer or Developer？"></a>Engineer or Developer？</h3><p>參閱 <a href="/2017/07/01/Management/Developer-or-Engineer/">Developer, or Engineer</a> 的整理。</p><h3 id="用中文還是英文寫？"><a href="#用中文還是英文寫？" class="headerlink" title="用中文還是英文寫？"></a>用中文還是英文寫？</h3><p>其中關於 JD 寫英文，我們內部也討論過。</p><p>有次我面試到幾位從矽谷回來面試的，當時我們的 JD 是寫英文的，也的確吸引到國際人才了，但很現實的就是，人家要得薪資就是國際級的水準 XDDD</p><p>所以，現實點，沒事不要給掰，那只會洗自己的臉 XDD</p><hr><h2 id="競爭"><a href="#競爭" class="headerlink" title="競爭"></a>競爭</h2><p>用人的那幾年，搶人是很常見的。</p><p>往往經過一面、二面、談薪資 … 最後終於要發 Offer 了，要決定 On Boarding Day 了，卻在最後一刻被打槍了。被拒絕的原因，通常就是對方同時有其他 Offer，往往名氣更大的公司、或者更好的待遇。</p><p>那個時期，台灣檯面上比較像外商風格的公司大概就 <code>KK 集團</code> (科科科技、KKStream, KKBox, KKTicket) 和 <code>趨勢科技</code>。這兩家是有幾年怎麼打都打不贏的，因為 類外商 風格與不錯的名聲、加上對新人的起薪待遇優於本土新創。</p><p>過了幾年，公司 IPO 上櫃之後狀況更好了，可以打贏前面那兩家了，但面對競爭的對象變成了跟 Amazon (AWS)、 Microsoft 搶 … 那時候真的是哭笑不得，一來是表示公司在業界地位提升了，已經進階到跟一線大廠比較了；二來是，這個待遇真的搶不贏 QQ</p><hr><h2 id="被抄"><a href="#被抄" class="headerlink" title="被抄"></a>被抄</h2><p>2016 ~ 2022 年這段時間，我花了不少心思在人力招募這一塊。想了很多策略、做了很多鋪墊、佈局，只為了可以再需要人的時候，可以找到好的人才，或者有人可以挑。</p><p>那幾年的確也找了不少優秀的人到團隊裡，現在那些成員都已經是公司的棟樑、幹部，或者已經高升到更好的工作去了。</p><p>底下這張圖，是當時團隊成員發現我寫的 JD 被競業抄的截圖，那時候很忙，知道自己的用心被友商抄寫，不知道該哭還是該笑，也算是一個里程碑吧 XDD</p><p><img src="/images/Management/Job-Description/20190814.png"></p><p>那時候在招募的心思都記錄在 <a href="/2018/08/20/Management/Overview-Hiring/">聊聊人力招募</a> 系列文。</p><hr><h2 id="夥伴"><a href="#夥伴" class="headerlink" title="夥伴"></a>夥伴</h2><p>每次寫 JD 心情都是這張圖，每個要用的人，都是夥伴。。。</p><p><img src="/images/Management/Job-Description/Six.jpg"></p><hr><h1 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h1><ul><li><a href="/2015/10/11/SQA/How-To-Be-An-SQA/">Software QA 的職能條件</a></li><li><a href="/2022/08/13/SQA/Path-to-Software-Testing/">演講：從理想、到現實的距離，開啟品味軟體測試之路</a></li><li><a href="/2023/05/23/About/2023-Software-Test-Practice/">共同著作《軟體測試實務 I、II》</a> - 第一冊 CH05 從零開始，軟體測試團隊建立實戰</li><li><a href="/2018/03/29/About/2018-Serverless-All-Star/">演講：Serverless All-Star - Ops as Code using Serverless</a> </li><li><a href="/2017/07/01/Management/Developer-or-Engineer/">Developer, or Engineer</a></li></ul><h2 id="人力招募-系列"><a href="#人力招募-系列" class="headerlink" title="人力招募 系列"></a>人力招募 系列</h2><ul><li><a href="/2018/08/20/Management/Overview-Hiring/">聊聊人力招募</a></li><li><a href="/2018/08/28/Management/Hiring-Step0-Initial/">零、準備篇：確認需求、條件、定位、市場狀況</a></li><li><a href="/2018/08/30/Management/Hiring-Step1-Find-the-Candidates/">一、萬事起頭難：面試名單從哪來？</a></li><li><a href="/2018/09/18/Management/Hiring-Step2-Interview-Skills/">二、見面談：招募第一關 面試</a></li><li><a href="/2018/09/22/Management/Hiring-Step3-Interview-Values-Attitude/">三、深度對談：價值觀</a></li><li><a href="/2018/09/27/Management/Hiring-Step4-Salary/">四、客觀談論：薪資</a></li><li><a href="/2018/10/07/Management/Hiring-Step5-Offer/">五、最後確認：報到時程</a></li><li><a href="/2018/12/22/Management/Hiring-Step6-Onboard/">六、到職後：訓練、目標、評核</a></li><li><a href="/2020/06/21/Management/Interview-Problems/">面試常見的問題</a></li><li><a href="/2022/08/13/SQA/Path-to-Software-Testing/">管理必經之路：遣散、解僱、辭呈</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;Job Description&lt;/code&gt;，簡稱 JD，是企業在招人，提供對外招募的資訊，包含 &lt;code&gt;工作內容&lt;/code&gt;、以及 &lt;code&gt;職缺條件&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;這篇整理以前在寫 JD 時背後的思路與心得。&lt;/p&gt;</summary>
    
    
    
    <category term="經營管理" scheme="https://rickhw.github.io/categories/%E7%B6%93%E7%87%9F%E7%AE%A1%E7%90%86/"/>
    
    <category term="人才管理" scheme="https://rickhw.github.io/categories/%E7%B6%93%E7%87%9F%E7%AE%A1%E7%90%86/%E4%BA%BA%E6%89%8D%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="主管" scheme="https://rickhw.github.io/tags/%E4%B8%BB%E7%AE%A1/"/>
    
    <category term="用人之道" scheme="https://rickhw.github.io/tags/%E7%94%A8%E4%BA%BA%E4%B9%8B%E9%81%93/"/>
    
    <category term="Job Description" scheme="https://rickhw.github.io/tags/Job-Description/"/>
    
    <category term="Interview" scheme="https://rickhw.github.io/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>純手工遊戲開發心得紀錄 - Java 2D RPG Game</title>
    <link href="https://rickhw.github.io/2025/12/19/About/Java-2D-RPG-Game/"/>
    <id>https://rickhw.github.io/2025/12/19/About/Java-2D-RPG-Game/</id>
    <published>2025-12-19T04:39:00.000Z</published>
    <updated>2025-12-25T14:14:59.255Z</updated>
    
    <content type="html"><![CDATA[<p>紀錄從 RyiSnow 的 <a href="https://www.youtube.com/playlist?list=PL_QPQmz5C6WUF-pOQDsbsKbaBZqXj4qSq">Java 2D RPG Game</a> 課程，手工完成 <code>Java 2D RPG (Role-Playing Game)</code> 的開發歷程與心得，遊戲玩法類似 <a href="https://zh.wikipedia.org/zh-tw/%E8%96%A9%E7%88%BE%E9%81%94%E5%82%B3%E8%AA%AA%E7%B3%BB%E5%88%97">薩爾達傳說</a> 的 動作 RPG (Action RPG)，相關紀錄放在 Youtube 播放清單: <a href="https://www.youtube.com/playlist?list=PL63J1r2PBvogQ2Un01ytl2bQ1OIrlrnLO">Game Learning and DevLog</a>、以及 <a href="https://github.com/rickhw/Java-2D-RPG-Game">Source Code</a>。</p><p><img src="/images/About/Java-2D-ARPG-Game/screenshot/attack_projectiles-fireball.png"></p><span id="more"></span><hr><h2 id="關於角色扮演遊戲-RPG-Game"><a href="#關於角色扮演遊戲-RPG-Game" class="headerlink" title="關於角色扮演遊戲 (RPG Game)"></a>關於角色扮演遊戲 (RPG Game)</h2><p>寫 RPG Game 一直是從小時候就有的夢想。小時候家裡還沒有電腦，只有紅白機可以玩 <a href="https://zh.wikipedia.org/zh-tw/%E5%90%9E%E9%A3%9F%E5%A4%A9%E5%9C%B0_(%E7%BA%A2%E7%99%BD%E6%9C%BA)">吞食天地</a> 的時候，就在想以後能不能自己寫類似的遊戲。後來因緣際會玩到了 <a href="https://zh.wikipedia.org/zh-tw/%E6%9C%80%E7%BB%88%E5%B9%BB%E6%83%B3III">Final Fantasy 3 (FF3，台灣當時翻譯：太空戰士)</a>，對整個遊戲的玩法、音樂、畫面震撼到不行，尤其是音樂。永遠忘不了駕著飛空艇，從空浮大陸飛出去的音樂與畫面，那感覺深深烙印在腦海裡，而整個故事的安排與起伏，至今都難以忘懷。從那個時候 (應該是小五？)，我就拿起紙筆寫一些天馬行空的劇本，然後幻想有一天可以寫寫自己的遊戲。</p><p>後來國二的時候，因緣機會玩到超任上的 <a href="https://zh.wikipedia.org/zh-tw/%E6%9C%80%E7%BB%88%E5%B9%BB%E6%83%B3V">Final Fantasy 5 (FF5)</a> ，又再一次的被音樂、故事震撼，國三畢業後，終於買到自己的超任，那時候超任上好像就只玩 FF5 了，其他遊戲玩得很少。</p><p>再往下就是第一次接觸電腦的時候了，學習了 QBasic，才知道這東西是可以寫出可以用的工具，或者遊戲。</p><p>之後唸書，到工作，一直都在寫商用應用程式、大型的 SaaS 系統，但「寫遊戲」一直都是在心裡的深處。</p><h2 id="為什麼要手刻遊戲？"><a href="#為什麼要手刻遊戲？" class="headerlink" title="為什麼要手刻遊戲？"></a>為什麼要手刻遊戲？</h2><p>為什麼純手工？沒考慮過使用 Game Engine？像是Unity、Unreal、RPG Maker … etc.</p><p>Unity 有研究過，但是太複雜，或者說花的時間太少，也抓不到重點。Unreal 更複雜，而且我沒有想做那麼「擬真」的遊戲。相對比較好上手的則是 Godot，所以有稍微研究過。RPG Maker 很久以前就研究過，但他做了我想做的事。</p><p>為什麼想自己刻遊戲？最核心的目的是：</p><ol><li>了解遊戲運作原理</li><li>計算機科學的應用</li><li>我本身就很喜歡研究科學與應用，也就是 1) + 2)</li></ol><p><code>遊戲運作原理</code> 像是底下的東西：</p><ol><li>GameLoop, FPS</li><li>TileMap (瓦片地圖), 座標系統</li><li>2D 繪圖</li><li>Collision 碰撞偵測</li><li>PathFinding 路徑規劃: <a href="https://youtu.be/lcPzFYIfcXA?si=4x1GZspirIm1iGmU">A* Search Algorithm</a></li><li>Particle 粒子效果</li></ol><p>還有其他更多就不列了，但這些在 2D RPG 裡算是很重要的概念，而且也是很有趣的東西。</p><p>其實寫遊戲的過程，對我來說就是享受，甚至比玩遊戲還有趣～</p><h3 id="術語"><a href="#術語" class="headerlink" title="術語"></a>術語</h3><p>除了學到技術，最有趣的是學到一些 <code>單字</code> 或者說 <code>術語</code>，整理如下：</p><ul><li>Sprites: 精靈</li><li>Tiles: 磚塊, Interactive Tile: 互動式磚塊</li><li>Game Loop</li><li>Projectile: 拋射物</li><li>Particle: 粒子效果</li><li>Scene: 場景</li><li>CutSense: 轉場</li><li>Mana: 魔力值</li><li>Dungeon: 地下城</li><li>Orc: 獸人</li><li>Invincible: 無敵狀態</li><li>Knock Back: 擊退</li></ul><h2 id="遊戲製作的四個面向"><a href="#遊戲製作的四個面向" class="headerlink" title="遊戲製作的四個面向"></a>遊戲製作的四個面向</h2><p>撇除營運面的，像是銷售、行銷 … 等，這次的學習歷程，我很粗淺的分析遊戲製作 (開發) 可以分成以下四個部分：</p><ol><li><code>技術 / 遊戲性</code>：包含前面提到的遊戲機制衍生的遊戲系統，以及遊戲種類需要設計的系統。</li><li><code>故事 / 劇本</code>：大部分的遊戲都會有個背景設定，像是 CyberPunk 2077 科幻背景、FF 系列的水晶系列、薩爾達傳說 … 等，故事是整個「玩」的理由與動機。</li><li><code>美術 / 視覺</code>：呈現出遊戲的視覺風格，2D 像素 (Pixel)、像宮崎駿的風格、3D 寫實風格 … etc</li><li><code>音樂 / 氛圍</code>：讓玩家最有帶入感的音樂，跟電影配樂一樣，針對角色、劇情事件、主題曲等角度而設計的音樂，都是影響遊戲體驗的關鍵。</li></ol><p>而這次學習的部分，主要是 1) 的部分。</p><p>也就是，有趣的部分，除了技術面的，還有很多可以玩，而這四個面向之中的 1) &#x2F; 2) &#x2F; 4) 都是我本來就有在涉略的領域，3) 美術則是我小時候很喜歡的，所以做遊戲需要參與的面向，都是我喜歡且有興趣的。</p><hr><h2 id="原始碼"><a href="#原始碼" class="headerlink" title="原始碼"></a>原始碼</h2><p>我把學習的歷程放在 GitHub 上，大部分的 Coding Style 都保留 RyiSnow 的寫法，我很少把個人的想法置入，保留純粹感，避免一些技術炫技污染。</p><p>程式主要開發環境是在 MacOS Tahoe &#x2F; VSCode，Java 環境則是 Java 17 &#x2F; 21 以及 Gradle。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">❯ java -version</span><br><span class="line">openjdk version <span class="string">&quot;21.0.2&quot;</span> 2024-01-16</span><br><span class="line">OpenJDK Runtime Environment GraalVM CE 21.0.2+13.1 (build 21.0.2+13-jvmci-23.1-b30)</span><br><span class="line">OpenJDK 64-Bit Server VM GraalVM CE 21.0.2+13.1 (build 21.0.2+13-jvmci-23.1-b30, mixed mode, sharing)</span><br><span class="line"></span><br><span class="line">❯ java -version</span><br><span class="line">openjdk version <span class="string">&quot;17.0.9&quot;</span> 2023-10-17</span><br><span class="line">OpenJDK Runtime Environment GraalVM CE 17.0.9+9.1 (build 17.0.9+9-jvmci-23.0-b22)</span><br><span class="line">OpenJDK 64-Bit Server VM GraalVM CE 17.0.9+9.1 (build 17.0.9+9-jvmci-23.0-b22, mixed mode, sharing)</span><br></pre></td></tr></table></figure><h3 id="執行"><a href="#執行" class="headerlink" title="執行"></a>執行</h3><p>需要 Gradle 8.x 以上才可以跑，可以參考 <a href="https://rickhw.github.io/2019/04/07/Coding/Java-Version-Manager/">SDKMan</a> 的介紹，準備 Java 生態系的工具。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始 config </span></span><br><span class="line"><span class="built_in">cp</span> config.sample.txt config.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">## 編譯</span></span><br><span class="line">❯ gradle clean build</span><br><span class="line"></span><br><span class="line"><span class="comment">## 啟動遊戲</span></span><br><span class="line">❯ gradle run</span><br><span class="line"></span><br><span class="line">$ Task :run</span><br><span class="line">[TileManager<span class="comment">#loadMap] finished to load map: [World1], index: [0]</span></span><br><span class="line">[TileManager<span class="comment">#loadMap] finished to load map: [Store], index: [1]</span></span><br><span class="line">[TileManager<span class="comment">#loadMap] finished to load map: [Dungeon01], index: [2]</span></span><br><span class="line">[TileManager<span class="comment">#loadMap] finished to load map: [Dungeon02], index: [3]</span></span><br><span class="line">[TileManager<span class="comment">#loadMap] finished to load map: [World1], index: [0]</span></span><br><span class="line">[TileManager<span class="comment">#loadMap] finished to load map: [Store], index: [1]</span></span><br><span class="line">[TileManager<span class="comment">#loadMap] finished to load map: [Dungeon01], index: [2]</span></span><br><span class="line">[TileManager<span class="comment">#loadMap] finished to load map: [Dungeon02], index: [3]</span></span><br><span class="line">18:46:32.001 [GameLoop] FPS: [60], Remaining Percent: [92.83], State: [Title Screen], Map: [World1], Position: [23,21]</span><br><span class="line">18:46:33.000 [GameLoop] FPS: [60], Remaining Percent: [93.98], State: [Title Screen], Map: [World1], Position: [23,21]</span><br><span class="line">18:46:34.000 [GameLoop] FPS: [60], Remaining Percent: [94.12], State: [Title Screen], Map: [World1], Position: [23,21]</span><br></pre></td></tr></table></figure><h3 id="Key-Event"><a href="#Key-Event" class="headerlink" title="Key Event"></a>Key Event</h3><ul><li>W&#x2F;A&#x2F;S&#x2F;D&#x2F;UP&#x2F;DOWN&#x2F;LEFT&#x2F;RIGHT: 移動</li><li>Enter: 攻擊</li><li>Space: 防禦</li><li>F&#x2F;J: Projectiles</li><li>V: 顯示 MiniMap</li><li>M: 顯示 Current Map</li><li>ESC: Options, 音量&#x2F;音效&#x2F;全螢幕</li></ul><h3 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h3><ul><li>T: Debug Mode, 顯示座標</li><li>X: God Mode</li><li>Z: Reset Monster</li></ul><h3 id="Branch"><a href="#Branch" class="headerlink" title="Branch"></a>Branch</h3><p>整個課程過程，在 Branch 有保留所有的紀錄，對應到 RyiSnow 的內容，學習上比較好查閱與理解。</p><p><img src="/images/About/Java-2D-ARPG-Game/github-branch.png"></p><p>其中有透過 gemini 幫忙重構 (branch: day57_refactor-by-gemini_ui-class, day57_refactor-by-antigravity)，但效果沒有預期得好。</p><hr><h2 id="截圖與紀錄"><a href="#截圖與紀錄" class="headerlink" title="截圖與紀錄"></a>截圖與紀錄</h2><h3 id="錄影"><a href="#錄影" class="headerlink" title="錄影"></a>錄影</h3><p>開發過程的完整錄影與紀錄，放在這個 <a href="https://www.youtube.com/playlist?list=PL63J1r2PBvogQ2Un01ytl2bQ1OIrlrnLO">Game Learning and DevLog</a> YouTube PlayList，每個錄影長度約在 10 分鐘以內，內容是大概是原作者的 2-3 個章節的速度。</p><p>我沒有額外花時間剪接，所以錄影內容都是 One Take 的解說與 Demo。</p><p><img src="/images/About/Java-2D-ARPG-Game/YouTube-PlayList.png"></p><h3 id="A-Search-Algorithm"><a href="#A-Search-Algorithm" class="headerlink" title="A* Search Algorithm"></a>A* Search Algorithm</h3><p>過程有趣的其中一塊是讓 Monster or NPC 跟著 Player 走的實作，使用的是 <a href="https://en.wikipedia.org/wiki/A*_search_algorithm">A* search algorithm</a>，底下 Demo 是用一個更簡單的例子，針對這個演算法額外的說明與解說。</p><p><img src="/images/About/Java-2D-ARPG-Game/a-star-seach-algorithm.png"></p><iframe width="560" height="315" src="https://www.youtube.com/embed/lcPzFYIfcXA?si=9ihUd-oY7esfi78z" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe><h3 id="攻擊與怪物"><a href="#攻擊與怪物" class="headerlink" title="攻擊與怪物"></a>攻擊與怪物</h3><p>攻擊怪物，以及怪物的 HP<br><img src="/images/About/Java-2D-ARPG-Game/screenshot/attack_monster-and-hp.png"></p><p>回擊怪物的拋射物 (Projectiles)<br><img src="/images/About/Java-2D-ARPG-Game/screenshot/attack_dynamic-combat.png"></p><p>格擋！ (類似薩爾達傳說的盾反？)<br><img src="/images/About/Java-2D-ARPG-Game/screenshot/attack_parry.png"></p><p>防禦<br><img src="/images/About/Java-2D-ARPG-Game/screenshot/attack_guarding.png"></p><p>玩家發射拋射物：魔法火球！<br><img src="/images/About/Java-2D-ARPG-Game/screenshot/attack_projectiles-fireball.png"></p><p>地下城的蝙蝠<br><img src="/images/About/Java-2D-ARPG-Game/screenshot/monster_bat.png"></p><p>大魔王：骷髏領主<br><img src="/images/About/Java-2D-ARPG-Game/screenshot/boss.png"></p><h3 id="環境與互動"><a href="#環境與互動" class="headerlink" title="環境與互動"></a>環境與互動</h3><p>世界地圖<br><img src="/images/About/Java-2D-ARPG-Game/screenshot/map-world.png"></p><p>地下城 (Gungeon)<br><img src="/images/About/Java-2D-ARPG-Game/screenshot/map-gungeon.png"></p><p>迷你地圖<br><img src="/images/About/Java-2D-ARPG-Game/screenshot/mini-map.png"></p><p>日夜循環模式<br><img src="/images/About/Java-2D-ARPG-Game/screenshot/day-night-mode.png"></p><p>砍樹: 互動式磚塊 (Interactive Tiles)<br><img src="/images/About/Java-2D-ARPG-Game/screenshot/destructible-tree.png"></p><p>推大石頭: 互動式元素 (NPC)<br><img src="/images/About/Java-2D-ARPG-Game/screenshot/interactive_bigrock.png"></p><p>商店 (Merchant)<br><img src="/images/About/Java-2D-ARPG-Game/screenshot/trade.png"></p><p>玩家的包包 (Inventory)<br><img src="/images/About/Java-2D-ARPG-Game/screenshot/inventory.png"></p><h3 id="Debug-1"><a href="#Debug-1" class="headerlink" title="Debug"></a>Debug</h3><p>顯示座標、碰撞區域、跟蹤路徑<br><img src="/images/About/Java-2D-ARPG-Game/screenshot/debug-mode.png"></p><hr><h2 id="用-AI-重寫-Remake-Java-to-Godot"><a href="#用-AI-重寫-Remake-Java-to-Godot" class="headerlink" title="用 AI 重寫: Remake - Java to Godot"></a>用 AI 重寫: Remake - Java to Godot</h2><p>整個課程完成後，我嘗試在 Antigravity (Google 的 AI IDE) 做類似復刻版 (Remake) 的事情，使用不同的 LLM，讓他們從理解現在的 Java 程式，然後在 Godot 做完整的 Remake，不過目前為止都還沒有讓我感到很滿意的結果。</p><p>有興趣可以看看底下的 Branch:</p><ul><li>day57_java-to-godot-by-antigravity-claude-opus-4.5-thinking</li><li>day57_to-godot-by-antigravity-claude-sonnet-4.5-thinking</li></ul><p>底下是 prompt:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">請了解現在的程式碼的架構與功能，了解之後，使用原本的素材，包含圖檔、音效、字型等資源 (放在 resources 目錄裡)，用 godot 復刻一模一樣功能的遊戲出來。</span><br><span class="line"></span><br><span class="line">復刻的時候，要利用 godot v4.5 遊戲引擎的特性，避免使用原本自己圖形計算的方法，像是原本 Java 有很多計算座標、縮放比例 (Scale)、計算碰撞 ... 等邏輯，這我想像應該是使用 Godot 有現成的 <span class="string">&quot;機制&quot;</span> 即可。幾個注意事項：</span><br><span class="line"></span><br><span class="line">1. Tile Size 是 16x16，實作地圖的時候，請處理等比放大效果，Tile 之間應該緊鄰。</span><br><span class="line">2. 大地圖應該有 Camera 功能</span><br><span class="line">3. 提供 Debug 功能：按下 T 的時候，用紅色顯示顯示 Tile 的邊 (Border)、以及座標 (col, row)</span><br><span class="line"></span><br><span class="line">請建立一個 godot 目錄，將復刻的程式碼以及素材放在 godot 目錄中。</span><br><span class="line"></span><br><span class="line">請分析完之後，展開工作階段計劃、以及每個階段的驗收流程，把這些文件放在 godot 目錄裡。</span><br><span class="line"></span><br><span class="line">沒問題後我們就開始。</span><br></pre></td></tr></table></figure><h3 id="截圖-未完成"><a href="#截圖-未完成" class="headerlink" title="截圖 (未完成)"></a>截圖 (未完成)</h3><p>底下是我測試的部分截圖</p><p><img src="/images/About/Java-2D-ARPG-Game/godot/sa.png"><br><img src="/images/About/Java-2D-ARPG-Game/godot/tile-issue.png"><br><img src="/images/About/Java-2D-ARPG-Game/godot/debug-mode-collision-1.png"><br><img src="/images/About/Java-2D-ARPG-Game/godot/debug-mode-collision-2.png"><br><img src="/images/About/Java-2D-ARPG-Game/godot/world-map-1.png"><br><img src="/images/About/Java-2D-ARPG-Game/godot/world-map-2.png"></p><h3 id="指標"><a href="#指標" class="headerlink" title="指標"></a>指標</h3><p>測試 AI 模型在以下 5 個關鍵維度 的指標能力：</p><ol><li>跨語言與跨範式的「語義翻譯」能力 (Semantic Translation)</li><li>架構重構能力 (Architectural Refactoring)</li><li>API 映射與領域知識 (Domain Knowledge Mapping)</li><li>知識庫的時效性與幻覺 (Knowledge Cutoff &amp; Hallucination)</li><li>長文本上下文關聯 (Long Context Reasoning)</li></ol><blockquote><p>驗證模型在軟體開發上，必須是是「工程師思維」而非單純的「翻譯機功能」。</p></blockquote><p>底下這兩個則是相對單純的重構，但效果也沒有覺得很好：</p><ul><li>day57_refactor-by-antigravity</li><li>day57_refactor-by-gemini_ui-class</li></ul><hr><h1 id="總要有個開始"><a href="#總要有個開始" class="headerlink" title="總要有個開始"></a>總要有個開始</h1><p>學生時代我的唸書讀完了的標準，就是自己出一份考卷，出完了考卷就讀完了 (自我感覺良好?)。工作後，大部分的人寫程式總要用 IDE，但我做的一些案子，卻是在開發 IDE。讀了很多經典小說 (金庸、艾希莫夫、朱少麟 …)，就想寫寫小說。玩了經典遊戲 (FF、Zelda)，寫個遊戲應該也是理所當然了，但這只能算入門而已。</p><h2 id="後續"><a href="#後續" class="headerlink" title="後續"></a>後續</h2><p>前面分析了 <code>遊戲製作</code> 提到四個面向：1) <code>技術 / 遊戲性</code>、2) <code>故事 / 劇本</code>、3) <code>美術 / 視覺</code>、4) <code>音樂 / 氛圍</code>。</p><p>所以後續還有很多事情可以做，然後持續深入的主題，整理如下：</p><ol><li><code>技術 / 遊戲性</code>：<ul><li>遊戲系統：遊戲機制、物理系統、角色系統、敵人設計、地圖系統、對話系統、操作系統、地圖系統、鏡頭控制 … etc</li><li>種類像是打擊、動作、角色、戰棋、養成 … etc 不同領域的遊戲性</li></ul></li><li><code>故事 / 劇本</code>：核心敘事，讓「玩」的理由與動機。</li><li><code>美術 / 視覺</code>：整體主視覺、風格、角色設計 … 等。</li><li><code>音樂 / 氛圍</code>：針對角色、劇情事件、主題曲、環境</li></ol><p>這上述事情通常至少需要一個團隊才能進行，底下 Final Fantasy 第一代的初始團隊的分工：</p><ul><li><code>坂口博信 (製作人/監督)</code>: 核心創始人，負責遊戲的整體企劃、劇情、系統設計與開發管理。</li><li><code>植松伸夫 (作曲家)</code>: 負責遊戲中所有經典配樂的創作。</li><li><code>天野喜孝 (概念設計師/原畫)</code>: 負責世界觀、角色與怪物的初期概念設計。</li><li><code>伊藤裕之 (程式/遊戲設計)</code>: 參與了關鍵的系統設計與程式實現，後續也設計了多代《FF》的戰鬥系統。</li><li><code>田中弘道 (程式/地圖設計)</code>: 參與遊戲地圖與世界地圖的製作。</li><li><code>高橋哲哉 (美術)</code>: 負責部分怪物與道具的繪製。</li></ul><p>差不多是我分析的四個方向。</p><h3 id="沒有工作要做什麼？"><a href="#沒有工作要做什麼？" class="headerlink" title="沒有工作要做什麼？"></a>沒有工作要做什麼？</h3><p><img src="/images/About/Java-2D-ARPG-Game/what-to-do-without-work.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;紀錄從 RyiSnow 的 &lt;a href=&quot;https://www.youtube.com/playlist?list=PL_QPQmz5C6WUF-pOQDsbsKbaBZqXj4qSq&quot;&gt;Java 2D RPG Game&lt;/a&gt; 課程，手工完成 &lt;code&gt;Java 2D RPG (Role-Playing Game)&lt;/code&gt; 的開發歷程與心得，遊戲玩法類似 &lt;a href=&quot;https://zh.wikipedia.org/zh-tw/%E8%96%A9%E7%88%BE%E9%81%94%E5%82%B3%E8%AA%AA%E7%B3%BB%E5%88%97&quot;&gt;薩爾達傳說&lt;/a&gt; 的 動作 RPG (Action RPG)，相關紀錄放在 Youtube 播放清單: &lt;a href=&quot;https://www.youtube.com/playlist?list=PL63J1r2PBvogQ2Un01ytl2bQ1OIrlrnLO&quot;&gt;Game Learning and DevLog&lt;/a&gt;、以及 &lt;a href=&quot;https://github.com/rickhw/Java-2D-RPG-Game&quot;&gt;Source Code&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/About/Java-2D-ARPG-Game/screenshot/attack_projectiles-fireball.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="About" scheme="https://rickhw.github.io/categories/About/"/>
    
    
    <category term="Java" scheme="https://rickhw.github.io/tags/Java/"/>
    
    <category term="RPG Game" scheme="https://rickhw.github.io/tags/RPG-Game/"/>
    
    <category term="Godot" scheme="https://rickhw.github.io/tags/Godot/"/>
    
  </entry>
  
  <entry>
    <title>R3 Model</title>
    <link href="https://rickhw.github.io/2025/06/29/Design/R3-Model/"/>
    <id>https://rickhw.github.io/2025/06/29/Design/R3-Model/</id>
    <published>2025-06-29T05:30:00.000Z</published>
    <updated>2025-07-30T10:43:45.291Z</updated>
    
    <content type="html"><![CDATA[<p>C4 model 是一個 2018 年之後發展出來的 架構描述方式，我在 2017 年底也在組織內部弄了類似概念的表達架構方式，很巧不巧，概念很 C4 model 很像，這段想法在我的著作 <a href="/2023/07/17/About/2023-SRE-Practice-and-IDP/">SRE實踐與開發平台指南</a> 有提到，底下用 <a href="https://www.facebook.com/rick.kyhwang/posts/pfbid03m9Fg2scvvNxH6VoFTmwDE2uVWDWoFbP5t2TZ9KZ9efGPqX5HpLFrKzrtT2sgFzNl?notif_id=1750850826246248&notif_t=feedback_reaction_generic&ref=notif">FB</a> 寫的草稿，讓 ChatGPT 幫我整理的想法～</p><span id="more"></span><hr><h1 id="R3-Model：以角色與責任為核心的系統架構分層模型"><a href="#R3-Model：以角色與責任為核心的系統架構分層模型" class="headerlink" title="R3 Model：以角色與責任為核心的系統架構分層模型"></a>R3 Model：以角色與責任為核心的系統架構分層模型</h1><p>在實務架構設計中，筆者長期關注的核心議題不僅僅是系統如何組合與部署，更在於這些系統元件在組織中的角色（Role）與責任（Responsibility）劃分。本文所介紹的 <strong>R3 Model</strong>，即是在此思維脈絡下逐步形成的一套架構視角，旨在協助團隊以一致的語意與責任邊界思考系統設計。</p><p>R3 Model 的核心觀點源自於物件導向設計（OOP）的封裝與介面觀念，並輔以康威定律（Conway’s Law）對組織結構與系統設計互為鏡像的洞見。模型共分為三層：</p><ol><li>High Level View（高層次視圖）</li><li>Logical View（邏輯視圖）</li><li>Physical View（實體視圖）</li></ol><p>以下針對各層做詳細說明。</p><hr><h2 id="1-High-Level-View：策略與邊界的呈現"><a href="#1-High-Level-View：策略與邊界的呈現" class="headerlink" title="1. High Level View：策略與邊界的呈現"></a>1. High Level View：策略與邊界的呈現</h2><p>High Level View 對應於 C4 Model 的 Context Layer，目的在於提供非技術利害關係人（如產品負責人、業務主管、決策者）一個宏觀且清晰的系統全貌。其主要包含：</p><ul><li>使用者角色與互動關係</li><li>系統間的整合與依賴關係</li><li>存取控制（Access Control, ACL）設計</li></ul><p>特別的是，R3 Model 在此層明確引入 ACL 的概念，靈感來自 OOP 中的 <code>public</code>、<code>protected</code>、<code>private</code> 權限修飾詞，藉以呈現不同系統元件之間的依賴強度與邊界彈性。此舉有助於促進治理層面的討論，例如系統間是否應建立明確 API 合約、資料是否應有等級存取等。</p><hr><h2 id="2-Logical-View：系統角色與責任的定義"><a href="#2-Logical-View：系統角色與責任的定義" class="headerlink" title="2. Logical View：系統角色與責任的定義"></a>2. Logical View：系統角色與責任的定義</h2><p>Logical View 對應 C4 Model 的 Container Layer，然其設計目標更偏重於揭示 <strong>系統內部職責的合理劃分</strong>，而非僅僅著眼於運行時的容器部署。其關注焦點包括：</p><ul><li>系統角色分類：Web、API Gateway、Database、Queue、Cache 等</li><li>各角色的責任範疇與 ACL 規則</li><li>搭配 User Story 或 User Scenario，描繪資料流的走向與行為密度</li></ul><p>本層設計亦受敏捷開發團隊組成啟發：如 Scrum Team 中的 PO、Dev、QA、Ops、Designer 等多元角色，系統亦應具備清晰的「誰該做什麼」配置。</p><p>此外，筆者進一步將資料流的特性定義為：</p><ul><li><strong>資料密度（Density）</strong>：代表資料處理的吞吐量需求</li><li><strong>資料溫度（Temperature）</strong>：代表資料互動的頻率或即時性</li></ul><p>透過這樣的維度，架構師與業務人員能更直觀地理解每個子系統的重要性與資源配置優先順序。</p><blockquote><p>本層的設計核心，在於<strong>建立跨部門對齊的語意圖譜</strong>，以利溝通與討論，而非立即導向實作技術。</p></blockquote><hr><h2 id="3-Physical-View：落實部署與營運觀點"><a href="#3-Physical-View：落實部署與營運觀點" class="headerlink" title="3. Physical View：落實部署與營運觀點"></a>3. Physical View：落實部署與營運觀點</h2><p>Physical View 在概念上並非完全等同於 C4 的 Component Layer，而更接近於部署層級（Deployment Architecture）與營運可行性分析。本層的設計聚焦於：</p><ul><li>各邏輯角色的部署實例數（副本）、伸縮策略與監控點配置</li><li>實作技術選型：如使用 Spring Boot、FastAPI、Node.js，資料庫採用 MySQL、PostgreSQL，訊息中介為 RabbitMQ、SQS、NATS 等</li><li>Infrastructure 與 Observability 架構的結合，例如搭配 Prometheus&#x2F;Grafana、ELK Stack、Tracing 工具等</li></ul><p>此層的設計使得系統可以與運維層有效對接，並作為 DevOps 團隊針對容量規劃、可用性分析、資安設計等核心議題的工作依據。</p><blockquote><p>R3 Model 發展初衷之一，即為解決觀測性不足所導致的部署與維運斷層問題。</p></blockquote><hr><h2 id="關於-Code-Layer-的補充"><a href="#關於-Code-Layer-的補充" class="headerlink" title="關於 Code Layer 的補充"></a>關於 Code Layer 的補充</h2><p>相較於 C4 Model 的第四層 Code Layer，R3 Model 並未進一步延伸至原始碼層級。此設計選擇源於筆者於設計本模型時，主要視角為系統架構與基礎建設層，並非針對單一服務的程式細節。然而，若需補足此層，亦可透過：</p><ul><li>Sequence Diagram（時序圖）</li><li>State Machine Diagram（狀態機）</li></ul><p>來進行行為與狀態的補充建模，支撐跨服務協作或狀態變化之設計需求。</p><hr><h2 id="命名與緣起：R3-Model-的實務脈絡"><a href="#命名與緣起：R3-Model-的實務脈絡" class="headerlink" title="命名與緣起：R3 Model 的實務脈絡"></a>命名與緣起：R3 Model 的實務脈絡</h2><p>R3 Model 並非源自於既有理論，而是在筆者於 2017 年左右，歷經多個實務系統架構案中逐步形成與歸納。直到多年後接觸到 C4 Model 時，才發現兩者前三層有高度相似性。</p><p>為求記憶與溝通方便，筆者將其命名為 R3，意指：</p><ol><li><strong>High Level View</strong> — 界定邊界與溝通語意</li><li><strong>Service Definition (Logical View)</strong> — 描述系統責任分工</li><li><strong>Go Live (Physical View)</strong> — 對應部署與營運策略</li></ol><p>目前此模型已在多個系統設計與導入中實證可行，並持續迭代中。雖未有廣泛使用者，但對於具有 Infra 或架構主導責任的工程師與架構師而言，R3 Model 可視為一套清晰的架構推演工具。</p><hr><h2 id="圖示說明"><a href="#圖示說明" class="headerlink" title="圖示說明"></a>圖示說明</h2><p>以下圖像呈現 R3 Model 的三層架構概念：</p><p><img src="/images/Design/R3-model/R3-model_by-ChatGPT_20250630.png"></p><hr><p>如果你對此模型有共鳴，或希望引入團隊實踐中，歡迎交流與討論，或協助擴充此模型在其他場景的應用。</p><hr><h1 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h1><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul><li><a href="https://en.wikipedia.org/wiki/Conway%27s_law">康威定律：系統設計如何映照組織結構</a></li><li><a href="https://c4model.com/">C4 Model 官方介紹</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;C4 model 是一個 2018 年之後發展出來的 架構描述方式，我在 2017 年底也在組織內部弄了類似概念的表達架構方式，很巧不巧，概念很 C4 model 很像，這段想法在我的著作 &lt;a href=&quot;/2023/07/17/About/2023-SRE-Practice-and-IDP/&quot;&gt;SRE實踐與開發平台指南&lt;/a&gt; 有提到，底下用 &lt;a href=&quot;https://www.facebook.com/rick.kyhwang/posts/pfbid03m9Fg2scvvNxH6VoFTmwDE2uVWDWoFbP5t2TZ9KZ9efGPqX5HpLFrKzrtT2sgFzNl?notif_id=1750850826246248&amp;notif_t=feedback_reaction_generic&amp;ref=notif&quot;&gt;FB&lt;/a&gt; 寫的草稿，讓 ChatGPT 幫我整理的想法～&lt;/p&gt;</summary>
    
    
    
    <category term="System Design" scheme="https://rickhw.github.io/categories/System-Design/"/>
    
    
    <category term="C4 Model" scheme="https://rickhw.github.io/tags/C4-Model/"/>
    
    <category term="康威定律" scheme="https://rickhw.github.io/tags/%E5%BA%B7%E5%A8%81%E5%AE%9A%E5%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>聊聊 API First 開發策略</title>
    <link href="https://rickhw.github.io/2025/03/08/Design/Gossip-API-First-Joureny/"/>
    <id>https://rickhw.github.io/2025/03/08/Design/Gossip-API-First-Joureny/</id>
    <published>2025-03-08T05:30:00.000Z</published>
    <updated>2025-06-27T12:21:44.235Z</updated>
    
    <content type="html"><![CDATA[<p>整理我個人這幾年來 (Since 2017) 接觸 API 有關的議題，共分成以下的大議題：</p><ol><li><code>API 設計</code>：重點在於滿足業務需求、控制範圍，包含資料模型、設計方法、流程與驗證</li><li><code>API 架構</code>：API Gateway、快取、效能、通訊協議、監控 … </li><li><code>API 治理與管理</code>：版本控管、導入策略 (API First &#x2F; Spec First &#x2F; Contract First)、上架政策、訂閱管理、問題排查</li><li><code>API 實作與模式</code>：包含常見的機制，像是 async、pagination、tracing、idempotence、batch、bulk … 等</li><li><code>API 軟體工程</code>：開發方法、測試方法、開發流程、跨團隊協作、文件</li></ol><p>以及寫在 <a href="https://www.facebook.com/rick.kyhwang/posts/pfbid02GVzcRhLpYhtpX4NbK876vfbrB3ZAWXVniLgD7842zH4XRA3SwYKerwirYAC9jg7ml">FB</a> 的隨筆，包含 API 在當代軟體開發的重要性、設計方法論、實務經驗談，以及一些背後的思路。</p><span id="more"></span><hr><h1 id="一、API-的重要性"><a href="#一、API-的重要性" class="headerlink" title="一、API 的重要性"></a>一、API 的重要性</h1><p>為啥組織需要透過 API？</p><h2 id="AWS-的基因-標準通訊介面-API"><a href="#AWS-的基因-標準通訊介面-API" class="headerlink" title="AWS 的基因 - 標準通訊介面 API"></a>AWS 的基因 - 標準通訊介面 API</h2><p><a href="/2019/10/24/Management/Learning-From-Amazon/">從 Jeff Bezos 與 Werner Vogels 學到的</a> 整理了這段在 2002 年寫下非常有名的 Memo，如下：</p><p><code>Jeff Bezos’ Mandate: Amazon and Web Services</code></p><ol><li>All teams will henceforth expose their data and functionality through <strong>service interfaces</strong>.</li><li><strong>Teams must communicate with each other through these interfaces</strong>.</li><li>There will be no other form of interprocess communication allowed: no direct linking, no direct reads of another team’s data store, no shared-memory model, no back-doors whatsoever. <strong>The only communication allowed is via service interface calls over the network</strong>.</li><li>It doesn’t matter what technology they use. HTTP, Corba, Pubsub, custom protocols — doesn’t matter.</li><li>All service interfaces, without exception, <strong>must be designed from the ground up to be externalizable</strong>. That is to say, the team must plan and design to be able to expose the interface to developers in the outside world. No exceptions.</li><li>Anyone who doesn’t do this <strong>will be fired</strong>.</li></ol><p>第四點提到的其他協議，像是 Corba &#x2F; Custom Protocols，這些會隨時代逐漸退場的，其他在這世代是都適合用的，特別第六點。</p><p>Amazon 本業是電商，其中 IT 屬於支援部門，但卻誕生了最成功的公有雲 - AWS (Amazon Web Services)，而這段 Memo 被認為是 AWS 能成功的基因，</p><h2 id="MACH-Architecture"><a href="#MACH-Architecture" class="headerlink" title="MACH Architecture"></a>MACH Architecture</h2><p>MACH 架構表示這四個概念： <code>Microservices（微服務）</code>、<code>API first</code>、<code>Cloud-native</code>、<code>Headless (無頭式架構)</code>，是現代企業數位轉型中的軟體設計理念。</p><p>底下用 ChatGPT 整理：</p><ul><li>MACH 起源於對傳統單體式架構的反思，MACH 鼓勵系統以小型、獨立部署的模組建構，透過 API 溝通，並部署在雲端環境中，使前後端可分離（Headless），提升靈活性與擴展性。</li><li>MACH 聯盟（MACH Alliance）於 2020 年成立，成員包括 commercetools、Contentstack、Amplience、EPAM 等，致力推動開放、可替換、最佳化體驗的軟體生態。其理念與組織影響了電商、金融、媒體等領域，促使企業拋棄封閉式平台，轉向組合式架構（Composable Architecture）。</li></ul><p>然而實務上導入 MACH 並不容易，挑戰包含系統整合成本高、團隊技術門檻高、測試與部署複雜度提升等。因此適合已有一定規模、追求敏捷與差異化的企業，而非所有組織皆適用。整體而言，MACH 架構代表一種軟體現代化的方向，但需要與組織成熟度搭配落地。</p><h2 id="Kubernetes-isn’t-about-containers"><a href="#Kubernetes-isn’t-about-containers" class="headerlink" title="Kubernetes isn’t about containers"></a><a href="https://blog.joshgav.com/posts/kubernetes-isnt-about-containers">Kubernetes isn’t about containers</a></h2><p>It’s about APIs; we’ll get to that shortly.</p><p>以下用 ChatGPT 摘要重點：</p><blockquote><p>Kubernetes 的價值不僅在於管理容器，而在於提供一套標準化的 API 框架，讓基礎設施能以軟體方式定義和操作。作者指出，雖然容器技術如 Docker 改變了應用部署方式，但 Kubernetes 的成功關鍵在於其統一的資源模型和控制器機制，使得不同類型的基礎設施資源（如計算、網路、儲存）能以一致的方式描述和管理。透過自訂資源定義（CRDs）和 Operator Framework，Kubernetes 的 API 被擴展到涵蓋資料庫、任務排程、訊息佇列等服務，形成一個可擴展的雲端服務標準。即使 Kubernetes 本身並非完美，其廣泛的採用和生態系統的成熟，使其成為現代雲端基礎設施的事實標準。 </p></blockquote><!--## AI 有 MCP & A2A 就夠了？這些概念嚴格講，都只是個包裝，技術上來講，本質都一樣，只要是系統對接，都一樣要有標準介面，所以 API 這個概念不會不見。至於是否是 OpenAPI 這個規格，就很難說，因為這個規格相對複雜。--><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>如果組織想要：</p><ul><li>組織如果要發揮跨團隊整合</li><li>組織想要降低溝通成本</li><li>組織想找出效能不佳，可以改善的地方</li><li>產品從外界來看，是一個產品，而不是一盤散沙</li></ul><p>那麼整頓內部的 API 標準化與設計是必要的，而 API 的品質則會體現出上述的反面問題。</p><hr><h1 id="二、設計方法論"><a href="#二、設計方法論" class="headerlink" title="二、設計方法論"></a>二、設計方法論</h1><p>這裡指的是 RESTful API 的設計，不會涉及實作。</p><h2 id="貧血型模型，API-x3D-CRUD？"><a href="#貧血型模型，API-x3D-CRUD？" class="headerlink" title="貧血型模型，API &#x3D; CRUD？"></a>貧血型模型，API &#x3D; CRUD？</h2><p>API 開發經常會被很多鄉民這樣說：</p><blockquote><p>整天就是在 CRUD，每天上班都在懷疑人生</p></blockquote><p>一些 Backend 工程師整天會抱怨工作內容就是 CRUD，之所以會有這樣的連結、認知，這與資料庫操作方式密切相關。</p><p><code>CRUD</code> 是 Create &#x2F; Read &#x2F; Update &#x2F; Delete 的縮寫，通常針對一筆資料的操作 (Operate)，背後描述的是針對「資料的操作」。當開發者直覺地將資料表對應到一組 CRUD API，就會出現 <code>API = CRUD</code> 的認知，然後就會出現自我懷疑的狀況。</p><p>在此想先引用一個來自於 Martin Fowler 在 2003 年提出的概念：<a href="https://martinfowler.com/bliki/AnemicDomainModel.html">貧血型模型 (Anemic Domain Model)</a>，文中提到大家在寫 Model 時，經常無腦的用 Getter &#x2F; Setter 來描述資料模型，卻缺乏透過模型的領域知識描述模型，像是領域特有的動作 &#x2F; 動詞。缺乏領域知識的模型就被稱為貧血型模型。而此描述的現象，跟用 CRUD 描述 API 有著一樣的現象，也就是只用 DB 操作 CRUD 來描述 API，因此我把這種只有 <code>CRUD API</code>，沒有領域概念的 API 稱為 <code>貧血型 API</code>。</p><p>實際上，優秀設計的 API 並不一定與資料表的操作一一對應。因為有些資源屬於 <code>聚合（Aggregation）</code>、有些是 <code>靜態資訊（如 Config、Version）</code>、有些則是狀態描述或操作指令，並無對應的資料落地。因此從設計角度出發，應先理解「資源」的本質，再決定是否與資料表做一對一對應，最終目的則是要設計出以領域知識為核心的操作與行為，使用者更容易理解、更能滿足業務需求的 API，這樣才不會陷入 CRUD 這種思路。</p><h2 id="以-Domain-為核心的設計出發點，以-AWS-EC2-Instance-為例"><a href="#以-Domain-為核心的設計出發點，以-AWS-EC2-Instance-為例" class="headerlink" title="以 Domain 為核心的設計出發點，以 AWS EC2 Instance 為例"></a>以 Domain 為核心的設計出發點，以 AWS EC2 Instance 為例</h2><p>當我們以 <code>Domain Knowledge</code> 作為設計基礎，每個資源（Resource）的操作會有其特有動詞，形成獨特的 API。舉例來說，AWS EC2 的 Instance 資源，一台 VM Instance 操作 包含以下動作 (動詞)：</p><blockquote><p>launch、start、stop、shutdown、reboot、terminate、change instance type … etc</p></blockquote><p>而一個 Instance 則會有以下的狀態移轉 (官方狀態圖)：</p><p><img src="/images/AWS/EC2/Instance_Lifecycle.png"></p><p>相關文章: <a href="/2016/07/09/AWS/EC2-Instance-Lifecycle-And-Troubleshooting/">EC2 Instance Lifecycle and Troubleshooting</a></p><p>這些 <code>狀態 (State)</code> 與 <code>動作 (Action)</code> 才是 EC2 Instance 的領域知識。</p><h2 id="使用狀態機描述的-RESTful-API-設計方法論"><a href="#使用狀態機描述的-RESTful-API-設計方法論" class="headerlink" title="使用狀態機描述的 RESTful API 設計方法論"></a>使用狀態機描述的 RESTful API 設計方法論</h2><p>用 AWS EC2 Instance 官方提供的 Lifecycle，透過 <code>狀態機 (Finite State Machine)</code> 重新分析過後得到以下狀態機：</p><p><img src="/images/Design/RESTful-API/ec2-state-machine_v20250308.png"></p><p>這張狀態機設計有幾個重點：</p><ol><li><code>狀態 (State)</code>:<ul><li>Instance 特有的領域用詞，這些狀態以 <code>名詞</code> 或者 <code>形容詞</code> 描述</li><li>圖中描述的狀態有 <code>固定狀態</code>, 以及 <code>過度狀態 (passing states)</code> 兩種。因為 Instance 操作本身是非同步的。</li><li>狀態機一定要有 <code>終止狀態 (End State)</code>，這個例子的結束是 <code>terminated</code></li><li>圖中灰底表示過度狀態，由系統控制</li></ul></li><li><code>領域行為 (Behaviro, 動詞)</code>:<ul><li>領域特定的行為，VM Instance 的行為就是前述提到的 launch、start、stop、shutdown、reboot、terminate … 等 <code>動詞</code></li><li><code>領域行為</code> 是使用者可以操作的動詞，用來觸發狀態之間的 <code>轉換 (Transition)</code></li><li>圖中可以表述的領域行為有 launch, start, stop, reboot, terminate … etc</li><li>本案例中的 <code>使用者</code> 預設是 end user of ec2，不包含 admin of ec2 instance</li></ul></li></ol><p>以此為原則，展開相對應的 API 設計，得到以下的設計藍圖：</p><p><img src="/images/Design/RESTful-API/ec2-restful-api_finite-state-machine_v20250308.png"></p><p>上圖中根據動作展開對應的 API，主要的有如下 (這不是全部)：</p><ul><li><code>POST /instances</code>: 建立 (launch) Instance</li><li><code>GET /instances/&#123;id&#125;</code>: 獲取 (retrieve) 指定的 Instance 資訊</li><li><code>DELETE /instances/&#123;id&#125;</code>: 刪除 (terminate) 指定的 Instance</li><li><code>PATCH /instances/&#123;id&#125;:start</code>: 啟動 (start) 指定的 Instance</li><li><code>PATCH /instances/&#123;id&#125;:stop</code> 關閉 (stop) 指定的 Instance</li><li><code>PATCH /instances/&#123;id&#125;:reboot</code> 重啟 (reboot) 指定的 Instance</li></ul><p>其中依據不同的實作技術，動作可能更多。</p><p>從這裡開始可以很明顯的感覺到，這已經不是 CRUD 概念的設計，而是以領域為核心的設計。其中在技術上使用了 <code>Standard Methods</code> 和 <code>Custom Methods</code> 這兩個概念。Standard Methods 表示 HTTP 幾個標準的 Methods，包含 GET &#x2F; POST &#x2F; PUT &#x2F; DELETE &#x2F; PATCH … 等，而 Custom Methods 則是透過 URI 的結構定義 CRUD 以外的 動詞，也就是圖中紫色底的動作。</p><blockquote><p>更多關於 Custom Methods 參閱我整理的簡報: API Design Patterns - <a href="https://www.slideshare.net/slideshow/ch09-custom-methods/257455321">CH9: Custom Methods</a></p></blockquote><h2 id="狀態機：狀態控制"><a href="#狀態機：狀態控制" class="headerlink" title="狀態機：狀態控制"></a>狀態機：狀態控制</h2><p>上圖透過狀態移轉設計出來的 RESTful API 因為版面關係無法表述所有的狀，所以透過另一種方式來所有排列組合列出來。透過 <code>狀態轉移（State Transition)</code> 的排列組合列表，表列出所有有可能的動作，這張表稱為 <code>State Table</code> or <code>Transition Table</code>。</p><p>這張表明確描述狀態 <code>起點 (From)</code> 與 <code>目標 (To)</code>之間的可操作性，如果可以操作，那是什麼動作？這樣可以明確的表示有哪些行為組合，展開後如下圖：</p><p><img src="/images/Design/RESTful-API/ec2-restful-api_state-table_v20250308.png"></p><p>圖中 From &#x2F; To 的每個交集動作:</p><ul><li>如果是 ✅ 代表可以操作，如果是 ❌ 代表不可操作。</li><li>能否操作，則由領域知識專家決定</li><li>每個可以操作的動作，都是領域專有的動詞，用詞由領域知識決定</li></ul><p>使用狀態機設計要注意的地方如下：</p><ul><li>狀態用詞為 State，使用為 <code>名詞</code>、<code>形容詞</code>，是有 <code>數量限制</code>、有 <code>先後次序</code>。<ul><li>經驗上來看，狀態 10 個為上限，再上去會複雜到很難處理</li><li>狀態數量 (N) 則表示有 <code>(N+1) x N</code> 的狀態移轉要思考</li><li><code>非同步</code> 的系統，則會有 <code>過度狀態 (Passing State)</code></li></ul></li><li>狀態機要有明確的 <code>起始</code> 與 <code>終止狀態 (End State)</code></li><li>狀態與狀態之間的轉換稱為 <code>狀態移轉 (Transition)</code><ul><li><code>狀態移轉</code> 不是由使用者直接指定，而是由動作觸發，結果則由 <code>業務邏輯決定 (Business Flow)</code></li><li>狀態移轉則透過動作 (動詞) 觸發</li><li>狀態移轉的條件，由領域知識決定</li></ul></li><li>狀態之間的連線代表 <code>動詞</code>，背後影含著：<code>誰 (who)</code> 能做的 <code>動作 (action)</code>，以及產生的 <code>事件 (event)</code><ul><li><code>who</code>: 代表授權機制，通常是 <code>垂直權限</code>，可以類似於 AWS IAM 的 Role，可以是 OAuth2 的 scope</li><li><code>action</code>: 動詞，同一個狀態移轉，可以透過多個動作觸發</li><li><code>event</code>: 事件則表示非同步行為，像是計算成本、觸發其他的資源的行為</li></ul></li></ul><blockquote><p>State 與 Status 的差異：Status 沒有數量限制、沒有先後次序、也沒有起始、終止等狀態，像是 HTTP Status Code</p></blockquote><p>狀態機在實作上，可以透過 State Table 的方式控制，也可以利用既有的框架，像是 <a href="https://spring.io/projects/spring-statemachine">Spring State Machine</a> 。</p><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><p>Q: 狀態機不見得適合所有的 resource 吧？</p><blockquote><p>經驗上來看，大部分的資源分成幾種：resource-based, record-based, request-based。resource-based 就是本文中提到的 VM，他有個實際的資源佔用，而 API 本身的資料庫算是另一份副本，來控制狀態。第二種是 record-based，也就是純粹的資訊紀錄，像是電商常見的訂單。第三種則是重點在處理程序 (time-bound)，通常不會被長時間保留的，像是 push &#x2F; sms 這種東西。但實際上無論哪一種，實際上都還是有個狀態，會比較容易理解。</p></blockquote><p>Q: 這個方法並沒有提到 Data Model，這樣的設計是可行的？</p><blockquote><p>Data Model 也是設計很重要的一環，本文先以 API URI 定義開始，背後核心的概念就是: 好的 API 應該具備容易理解的特性，也就是還沒有看 Data Model 就大概知道可以做什麼。Data Model 有機會之後來分享設計的想法，但業界最好的範例就是 K8s 的 API.</p></blockquote><h2 id="小結-1"><a href="#小結-1" class="headerlink" title="小結"></a>小結</h2><p>當我們畫出資源的狀態機，並標示狀態轉移，即可初步知道要實作哪些 API，下一步就是透過產開 <code>Transition Table</code>，分析出所有可能組合，再用刪去法去除不合理或不必要的部分，留下即為必要實作的 API。透過此方式設計出的 API，既符合 RESTful 精神，也更容易理解與使用。反之，純以 CRUD 寫出的 API，往往缺乏 Domain 的思考，只是機械式的實作。而且範圍是模糊且不清楚的。</p><p>上述的設計方法論只是個基本摘要，但已經包含整個設計核心的論述與思路。重點如下:</p><ol><li>以資源為核心的領域知識, 類似於 ER Digram or Class Diagram 的概念</li><li>每個資源以狀態機為核心</li><li>RESTful API 透過狀態機展開</li></ol><p>整個設計背後的思路是：</p><blockquote><p>以使用者角度出發，使用者可以 <code>怎麼用</code>，而不是 API 的開發者 <code>怎麼做</code>。</p></blockquote><p>對使用者而言，就是拿到一個語意明白、意圖清晰、有限範圍，容易使用 API。反之，這樣的設計對於 API 開發者會考驗其真實的實作實力，例如 CQRS、State Machine 的控制等。</p><hr><h1 id="三、API-First-導入經驗談"><a href="#三、API-First-導入經驗談" class="headerlink" title="三、API First 導入經驗談"></a>三、API First 導入經驗談</h1><p>如同 MACH 架構提到的，實務上要導入 API First Approach 並不容易，會有方方面面的挑戰。底下摘要一些導入過程曾經遇到的問題：</p><ol><li>讓團隊意識到 OpenAPI 規格的重要性需花費不少時間。<ul><li>所有細節其實都寫在規格裡，但出現問題時大家往往不會先翻規格。</li><li>這與許多工程師不寫文件，卻抱怨別人系統沒有文件的現象如出一轍。</li></ul></li><li>API 規格可以反映設計者是否具備 OOAD &#x2F; DDD 的觀念。</li><li>優秀的 API 設計應具高度重用性與易用性，應視為「積木」；<ul><li>而商業流程應由 Application 層負責。</li><li>若 API 設計者將業務邏輯寫進 API 中，將導致耦合升高、重用困難。</li></ul></li><li>API 只要定義好 Swagger YAML，Client &#x2F; Server 便可同步開工。</li><li>OpenAPI v3.0 規格在大型系統開發上仍有不足之處<ul><li>例如缺乏模組化能力，<code>$ref</code> 的 YAML path 存在侷限，難以切分大型模組。</li></ul></li><li>雖然市面上有不少 OpenAPI 工具，但要找到真正適用、穩定的仍需耗費時間，整體缺乏標準化與生態系統整合。</li><li>API 必須與 Use Case 搭配才能完整理解。<ul><li>API 主要描述結構（空間），但無法說明行為（時間），兩者結合才是產品真正的使用情境。</li></ul></li><li>許多人認同 API First，但實際仍先寫程式，再反推生成 API Spec，因為這樣做比較容易、趕 Deadline 比較實際。</li><li>同理，使用他人 API 的開發者也常發生類似狀況。<ul><li>即使認同 API First，拿到 API Spec 後也常是看不懂，或拖到最後一天才看。</li></ul></li><li>API 設計過程本質上是一面「照妖鏡」，能照出團隊間的溝通問題。<ul><li>無論是設計者、使用者還是提供者，往往可從中看出問題根源，有些甚至是歷史遺留的政治問題，API First 本身無法解決。</li></ul></li><li>API Spec 就是產品規格文件，應是所有產品成員都看得懂的文件。<ul><li>但現實是，通常只有撰寫者看得懂，大多數團隊並不會實際撰寫 API Spec，也因此沒人真正了解產品具體規格。</li></ul></li><li>在沒有正式產品規格的情況下，API Spec 是最基本、最完整、也最具體的形式，甚至比各種簡報或文件更具參考價值。</li></ol><p>「規格」是能讓工程師開始動手做，並可透過驗證確認是否正確的文件。就如同 RFC 定義了 DNS、HTTP 的標準。產品規格，是讓團隊可以開發、讓用戶可以驗收的具體依據；而 API Spec 同時具備這兩者的特性，並成為開發者與用戶之間的關鍵橋梁。</p><hr><h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><h2 id="設計方法論的發想背景"><a href="#設計方法論的發想背景" class="headerlink" title="設計方法論的發想背景"></a>設計方法論的發想背景</h2><p>這幾年實務設計 RESTful API，我習慣以「有限狀態機 (FSM)」的思維搭配 OOD 的 Class 設計進行 API 設計。其核心包含：資源、狀態、動作、角色。</p><p>2012 年左右，因緣際會下開始研究 <a href="/2015/01/06/Management/%E5%8D%94%E5%90%8C%E5%90%88%E4%BD%9C%E7%B3%BB%E7%B5%B1%E5%BB%BA%E5%88%B6%E8%88%87%E5%B0%8E%E5%85%A5-%E4%BB%A5-Redmine-%E7%82%BA%E4%BE%8B/">專案管理系統 (Project Management System)</a>，那時候接觸了要錢的 JIRA 以及不要錢的 Redmine，後來選擇不要錢的 Redmine。Redmine 的設計非常有彈性，撇除專案管理的功能，最核心的概念就是可以定義每種 Tracker Type 的狀態，以及透過狀態移轉方式控制流程，同時可以針對不同角色，設定不同流程的走向。當時我是負責整個團隊的軟體生命週期規劃，包含需求、設計、開發、測試、部署、維運等等，所以對於流程控制的需求非常強烈。Redmine 的這個設計概念讓我非常滿意，也因此開始研究 FSM 的概念。從 Feature、Bug、Deployment、Task 等等，每個 Tracker Type 都可以定義不同的狀態、狀態移轉的方式、哪個站點可以卡控 … 等。</p><p>這段設計過程，在團隊獲得應證，團隊跑的方式不是現在流行的 Scrum，而是自己定義的流程，每個人都知道自己的角色、責任，以及流程的走向。by the way，這概念也運用在管裡整個公司的 IT 資產管理、以及人事狀況，都是用 Redmine 來管理，但我只是把方法教給其他人，我只是在旁邊看著。後來也玩了像是 Azure DevOps (VSTS)，其實也都有一樣的概念在。</p><p>後來在 2017 年參與 API Gateway 架構設計與導入，在 Review 公司既有 API 時，我注意到 RESTful API 的設計，其實可以用 FSM 的概念來思考，只是針對已經「落地」的 API 就有點晚了。</p><p>2020 年因應公司的 API First 策略，執行 API Platform 的規劃，包含三大部分：</p><ol><li>API 設計方法論（Design Methodology）</li><li>API 架構設計（Architecture）</li><li>API 管理與治理（Management）</li></ol><p>Design Methodology 目的就是要找出一個設計方法，可以讓公司的 API 設計對標一些大型組織的設計，那時候跟同事一起研究 K8s API、GCP API、Shopify API、AWS API、GitHub API、Azure API … 等。這些 API 都有一個共通點，就是資源的狀態移轉，以及角色的權限控管。加上之前我使用 Redmine 等經驗，所以嘗試把 FSM 的概念帶入 RESTful 設計裡，搭配 OOD 的 Class Diagram 設計，這樣的設計方法論，可以讓 API 設計更有邏輯性，也更容易讓使用者理解。同時可以透過刪去法，減少不必要的 API，讓 API 的語意更清晰。</p><blockquote><p>更多設計的方法，也可以參閱 Andrew Blog 的文章：<a href="https://columns.chicken-house.net/2022/10/26/apifirst/">API First 的開發策略</a>、<a href="https://columns.chicken-house.net/2023/01/01/api-design-workshop/">API Design Workshop</a>、<a href="https://columns.chicken-house.net/2022/04/25/microservices16-api-implement/">從狀態圖來驅動 API 的實作範例</a>，基本上跟上述概念是一樣的。</p></blockquote><p>API Architecture 的工作重點則是要規劃 API Gateway 以及內部系統通訊協議，有興趣可以看看 2018 我在 AWS Summit 分享的 <a href="/2018/07/18/About/20180718-API-Gateway/">邁向 API 經濟 - API Gateway 導入之旅</a>、<a href="/2018/01/24/DistributedSystems/Overview-API-Gateway/">AWS API Gateway 學習的系列文</a>、<a href="https://www.slideshare.net/rickhwang/study-notes-using-an-api-gateway">Study Notes - Using an API Gateway</a>。</p><p>API Management 則是要規劃 API 的生命週期管理，包含 API 設計、API 開發、API 測試、API 上線、API 監控、API 退市等等。這部分也是大坑，有空再來寫 XDD  </p><p>過程中，啃了不少書，有三本推薦的:</p><ol><li><a href="https://www.tenlong.com.tw/products/9781617295850">API Design Patterns</a>  <ul><li>延伸閱讀：<a href="https://google.aip.dev/">https://google.aip.dev</a> - 作者在 Google 寫的</li></ul></li><li><a href="https://www.tenlong.com.tw/products/9786263243224">Continuous API Management</a></li><li><a href="https://www.tenlong.com.tw/products/9781492090632">Mastering API Architecture</a></li></ol><p>而執行面則展開以下兩大部分：</p><ol><li><code>API 實作與模式</code>：包含常見的機制，像是 async、pagination、idempotence、batch、bulk … 等</li><li><code>API 軟體工程</code>：開發方法、測試方法、開發流程、跨團隊協作</li></ol><hr><h1 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h1><h2 id="相關文章"><a href="#相關文章" class="headerlink" title="相關文章"></a>相關文章</h2><ul><li><a href="/2019/10/24/Management/Learning-From-Amazon/">從 Jeff Bezos 與 Werner Vogels 學到的</a></li><li>API Design Patterns: <a href="https://www.slideshare.net/slideshow/ch09-custom-methods/257455321">Custom Methods</a></li><li><a href="/2023/06/24/DistributedSystems/API-First_Communication-Protocol/">API 設計 - 摘要 API 通訊模式與協議</a></li><li><a href="/2023/07/02/DistributedSystems/API-First_Integration-Matrix/">API 設計 - API 整合矩陣</a></li><li><a href="https://www.threads.net/@rick.kyhwang/post/DGjXMqkTU-b">API First Approach 導入的實際問題</a>, <a href="https://www.facebook.com/rick.kyhwang/posts/pfbid02GVzcRhLpYhtpX4NbK876vfbrB3ZAWXVniLgD7842zH4XRA3SwYKerwirYAC9jg7ml">FB</a></li><li><a href="/2018/07/18/About/20180718-API-Gateway/">邁向 API 經濟 - API Gateway 導入之旅</a></li><li><a href="https://www.slideshare.net/rickhwang/study-notes-using-an-api-gateway">Study Notes - Using an API Gateway</a></li></ul><h2 id="發想"><a href="#發想" class="headerlink" title="發想"></a>發想</h2><ul><li><a href="/2015/01/06/Management/%E5%8D%94%E5%90%8C%E5%90%88%E4%BD%9C%E7%B3%BB%E7%B5%B1%E5%BB%BA%E5%88%B6%E8%88%87%E5%B0%8E%E5%85%A5-%E4%BB%A5-Redmine-%E7%82%BA%E4%BE%8B/">協同合作系統建制與導入 - 以 Redmine 為例</a></li><li><a href="/2019/05/21/AWS/Study-Notes-Step-Functions/">Study Notes - Step Functions</a></li><li><a href="/2017/08/19/Redmine/Issue-Tracking_in_Redmine/">Issue Tracking in Redmine</a></li></ul><h2 id="推薦閱讀"><a href="#推薦閱讀" class="headerlink" title="推薦閱讀"></a>推薦閱讀</h2><ul><li>Andrew 的文章<ul><li><a href="https://columns.chicken-house.net/2022/10/26/apifirst/">架構師觀點 - API First 的開發策略</a></li><li><a href="https://columns.chicken-house.net/2023/01/01/api-design-workshop/">架構師觀點 - API Design Workshop</a></li><li><a href="https://columns.chicken-house.net/2022/04/25/microservices16-api-implement/">微服務架構 - 從狀態圖來驅動 API 的實作範例</a></li></ul></li><li>相關書籍：<ul><li><a href="https://www.tenlong.com.tw/products/9781617295850">API Design Patterns</a>, <a href="https://google.aip.dev/">https://google.aip.dev</a> - 作者在 Google 寫的</li><li><a href="https://www.tenlong.com.tw/products/9786263243224">Continuous API Management</a></li><li><a href="https://www.tenlong.com.tw/products/9781492090632">Mastering API Architecture</a></li></ul></li><li><a href="https://martinfowler.com/bliki/AnemicDomainModel.html">Anemic Domain Model</a> - Martin Fowler</li><li><a href="https://blog.joshgav.com/posts/kubernetes-isnt-about-containers">Kubernetes isn’t about containers, It’s about APIs; we’ll get to that shortly.</a> - Josh Gavant</li><li><a href="https://machalliance.org/mach-technology">MACH Technology Explained</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;整理我個人這幾年來 (Since 2017) 接觸 API 有關的議題，共分成以下的大議題：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;API 設計&lt;/code&gt;：重點在於滿足業務需求、控制範圍，包含資料模型、設計方法、流程與驗證&lt;/li&gt;
&lt;li&gt;&lt;code&gt;API 架構&lt;/code&gt;：API Gateway、快取、效能、通訊協議、監控 … &lt;/li&gt;
&lt;li&gt;&lt;code&gt;API 治理與管理&lt;/code&gt;：版本控管、導入策略 (API First &amp;#x2F; Spec First &amp;#x2F; Contract First)、上架政策、訂閱管理、問題排查&lt;/li&gt;
&lt;li&gt;&lt;code&gt;API 實作與模式&lt;/code&gt;：包含常見的機制，像是 async、pagination、tracing、idempotence、batch、bulk … 等&lt;/li&gt;
&lt;li&gt;&lt;code&gt;API 軟體工程&lt;/code&gt;：開發方法、測試方法、開發流程、跨團隊協作、文件&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以及寫在 &lt;a href=&quot;https://www.facebook.com/rick.kyhwang/posts/pfbid02GVzcRhLpYhtpX4NbK876vfbrB3ZAWXVniLgD7842zH4XRA3SwYKerwirYAC9jg7ml&quot;&gt;FB&lt;/a&gt; 的隨筆，包含 API 在當代軟體開發的重要性、設計方法論、實務經驗談，以及一些背後的思路。&lt;/p&gt;</summary>
    
    
    
    <category term="System Design" scheme="https://rickhw.github.io/categories/System-Design/"/>
    
    
    <category term="API Gateway" scheme="https://rickhw.github.io/tags/API-Gateway/"/>
    
    <category term="Finite-State Machine" scheme="https://rickhw.github.io/tags/Finite-State-Machine/"/>
    
    <category term="API First" scheme="https://rickhw.github.io/tags/API-First/"/>
    
    <category term="RESTful" scheme="https://rickhw.github.io/tags/RESTful/"/>
    
    <category term="API" scheme="https://rickhw.github.io/tags/API/"/>
    
    <category term="API Design" scheme="https://rickhw.github.io/tags/API-Design/"/>
    
    <category term="API Platform" scheme="https://rickhw.github.io/tags/API-Platform/"/>
    
    <category term="API Architecture" scheme="https://rickhw.github.io/tags/API-Architecture/"/>
    
    <category term="API Management" scheme="https://rickhw.github.io/tags/API-Management/"/>
    
    <category term="Headless" scheme="https://rickhw.github.io/tags/Headless/"/>
    
  </entry>
  
  <entry>
    <title>Development Machine</title>
    <link href="https://rickhw.github.io/2025/02/02/Coding/Development-Machine/"/>
    <id>https://rickhw.github.io/2025/02/02/Coding/Development-Machine/</id>
    <published>2025-02-02T10:21:00.000Z</published>
    <updated>2025-06-27T12:21:44.310Z</updated>
    
    <content type="html"><![CDATA[<p>整理一下我個人開發環境的資訊。</p><span id="more"></span><h2 id="Programming-Language"><a href="#Programming-Language" class="headerlink" title="Programming Language"></a>Programming Language</h2><p>以 Java 為主，主要是透過 <a href="/2019/04/07/Coding/Java-Version-Manager/">SDK</a> 這個 Java Version Manager 為主，底下是我安裝的部分：</p><ol><li>各種 Provider 和版本的 JDK，像是 Amazon 的 Corretto, OpenJDK, Oracle 的 GraalVM CE, Zulu … 等</li><li>安裝 maven, gradle 等</li><li>Framework: Spring Boot, </li><li>Performance: jmeter, VisualVM</li></ol><p>SDK 本身支援很多 Java 社群常見的開發工具，我在 Ubuntu or macOS 都會使用。</p><h2 id="OS-macOS-Linux-Ubuntu"><a href="#OS-macOS-Linux-Ubuntu" class="headerlink" title="OS: macOS, Linux - Ubuntu"></a>OS: macOS, Linux - Ubuntu</h2><p>我習慣開發時應用程式的 runtime 跟 Production 一致，所以開發時會盡可能讓應用程式一開始就跑在 Linux 為主的環境，避免未來一些因為 OS 造成的問題。</p><p>但是人機界面，macOS 其實還是比較順手，當然現在 Ubuntu 的 GNOME 其實也很不錯。所以環境我大概都會這樣搭配：</p><ol><li>IDE: 放在 macOS or Windows</li><li>Runtime: 放在 remote 的 linux or container<ul><li>透過 VM 的方式開一台 Linux (Ubuntu)</li><li>用 docker-compose 開啟相關的依賴元件，像是 MySQL</li></ul></li></ol><h2 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h2><p>主力 IDE 的選擇以通用性高的為原則，目前主要是用 VSCode，也搭配一些像是 Copilot 之類。</p><p>其他新的 Cursor &#x2F; Windsurf 目前處於嚐鮮狀態。</p><p>VSCode 使用方式有兩種，完全在 macOS 上，和透過 Remote Explorer + UTM 開一台 Ubuntu.</p><p>我現在比較少用 <a href="/2022/07/04/DistributedSystems/Inspired-Design-From-Eclipse/">Eclipse</a>, 或者 IntelliJ, 主要是任務大多是 PoC 目的，所以 IDE 盡可能簡單。</p><h3 id="完全在-macOS-開發-目前"><a href="#完全在-macOS-開發-目前" class="headerlink" title="完全在 macOS 開發 (目前)"></a>完全在 macOS 開發 (目前)</h3><p>IDE 和 docker-compose 都在本機跑，docker 則是使用 <a href="https://orbstack.dev/">orbstack</a>.</p><ul><li>優點：開發效率很好，效能也最佳</li><li>缺點：有些問題在 linux 會發生的，會晚一點發現，像是 docker-compose 的權限問題</li></ul><h3 id="Remote-Development-IDE-在-macOS-runtime-都在-VM"><a href="#Remote-Development-IDE-在-macOS-runtime-都在-VM" class="headerlink" title="Remote Development: IDE 在 macOS, runtime 都在 VM"></a>Remote Development: IDE 在 macOS, runtime 都在 VM</h3><p>VS Code 跑在 macOS，然後透過 Remote Explorer 的 SSH Tunnel 連到 UTM 裡的 Ubuntu 開發。</p><p>docker-compose 的 stack 和 application 都跑在 ubuntu 上。</p><ul><li>優點：問題會提早發現，可以提早修復</li><li>缺點：效能沒有全部都跑在本機好，相關可以參閱 <a href="/2024/10/13/Coding/Virtualization-Performance/">VMWare and UTM Performance Benchmark</a></li></ul><h2 id="System-Stack-docker-compose"><a href="#System-Stack-docker-compose" class="headerlink" title="System Stack: docker-compose"></a>System Stack: docker-compose</h2><p>最近在開發的環境，大量使用 docker-compose 建立相關資源，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">❯ docker-compose up -d</span><br><span class="line">[+] Running 12/12</span><br><span class="line"> ✔ Container asimov-cache-adminer_phpRedisAdmin-1  Started                                                              0.5s</span><br><span class="line"> ✔ Container asimov-rdb_mariadb-1                  Healthy                                                             30.7s</span><br><span class="line"> ✔ Container asimov-cache_redis-1                  Started                                                              0.3s</span><br><span class="line"> ✔ Container asimov-queue_rabbitmq-1               Started                                                              0.5s</span><br><span class="line"> ✔ Container asimov-dashboard_grafana-1            Started                                                              0.7s</span><br><span class="line"> ✔ Container asimov-search_elasticsearch-1         Started                                                              0.5s</span><br><span class="line"> ✔ Container asimov-metric_prometheus-1            Started                                                              0.3s</span><br><span class="line"> ✔ Container asimov-node-exporter-1                Started                                                              0.6s</span><br><span class="line"> ✔ Container asimov-rdb-adminer_phpmyadmin-1       Started                                                             31.0s</span><br><span class="line"> ✔ Container asimov-api-gateway_apache-apisix-1    Started                                                              0.5s</span><br><span class="line"> ✔ Container asimov-dashboard_kibana-1             Started                                                              0.9s</span><br><span class="line"> ✔ Container asimov-logshipper_webapi-filebeat-1   Started</span><br></pre></td></tr></table></figure><p>總共 12 個 container，不包含應用程式本身。其中包含了：</p><ul><li>data<ul><li>Relational Database: MySQL, MariaDB</li><li>Message Queue: RabbitMQ</li><li>Cache: Redis</li></ul></li><li>Logging<ul><li>Elasticsearch</li><li>Filebeat</li></ul></li><li>Dashboard<ul><li>Kibana</li><li>Grafana</li></ul></li><li>Metric<ul><li>Prometheus</li><li>Node Exporter</li></ul></li><li>Networking<ul><li>APISix (API Gateway)</li></ul></li></ul><p>這些東西都以最小配置為原則，主要是開發過程 functional test 使用，跑起來約要消費掉 10GiB 的記憶體。</p><p>加上 IDE 佔用的資源 (3GiB) ，基礎消費約 13GiB，加上一倍的 buffer，建議至少要有 32GiB 的記憶體。這不包含開發時會同時開 Browser 或者 Ollama (LLM) 找資源問問題所需要的記憶體。</p><h2 id="資源分配"><a href="#資源分配" class="headerlink" title="資源分配"></a>資源分配</h2><p>比較好的開發資源分配，我會想把 system stack 部分都跑在其他獨立的機器，然後 macOS 只跑 IDE，這樣整體開發的平橫性會好很多。</p><p>不然就要弄一台規格很好的 MacBook Pro，然後所有東西都跑在上面。</p><h2 id="理想的開發資源"><a href="#理想的開發資源" class="headerlink" title="理想的開發資源"></a>理想的開發資源</h2><p>資源牽涉到成本問題，所以還是要先說一下主要用途：</p><ol><li>開發應用程式</li><li>模擬測試、效能測試</li></ol><p>單純開發應用程式，其實需要的資源不多。但要跑一些模擬測試，或者效能測試，就會需要比較多的資源，像是：</p><ol><li>分散式資料庫的一致性驗證</li><li>K8s Cluster</li><li>模擬大量使用者 Client 需要的資源.</li></ol><p>所以摘要理想的資源需要：</p><ol><li>開發功能：最少 32GiB，最好 64GiB，或者分開兩台機器，兩台都 64 GiB</li><li>測試：64G 三台以上，分別擔任開發 &#x2F; 測試 Client &#x2F; System Stack 部署三個部分</li></ol><hr><h1 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h1><ul><li><a href="/2019/04/07/Coding/Java-Version-Manager/">SDK - Java Version Manager</a></li><li><a href="/2024/10/13/Coding/Virtualization-Performance/">VMWare and UTM Performance Benchmark</a></li><li><a href="/2023/01/17/Container/Install-K3s-on-MBPR-M1/">K8s 學習筆記 - 在 MacBook Pro M1 安裝 K3s</a></li><li><a href="/2022/07/04/DistributedSystems/Inspired-Design-From-Eclipse/">摘要 Eclipse 設計的啟發：當代 SaaS 分散式架構的關鍵設計</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;整理一下我個人開發環境的資訊。&lt;/p&gt;</summary>
    
    
    
    <category term="Coding" scheme="https://rickhw.github.io/categories/Coding/"/>
    
    
    <category term="Docker" scheme="https://rickhw.github.io/tags/Docker/"/>
    
    <category term="Java" scheme="https://rickhw.github.io/tags/Java/"/>
    
    <category term="macOS" scheme="https://rickhw.github.io/tags/macOS/"/>
    
    <category term="VSCode" scheme="https://rickhw.github.io/tags/VSCode/"/>
    
    <category term="Docker-Compose" scheme="https://rickhw.github.io/tags/Docker-Compose/"/>
    
  </entry>
  
  <entry>
    <title>VMWare and UTM Performance Benchmark</title>
    <link href="https://rickhw.github.io/2024/10/13/Coding/Virtualization-Performance/"/>
    <id>https://rickhw.github.io/2024/10/13/Coding/Virtualization-Performance/</id>
    <published>2024-10-12T19:33:00.000Z</published>
    <updated>2025-06-27T12:21:44.309Z</updated>
    
    <content type="html"><![CDATA[<p>我在開發時，很習慣用 Linux 當作主要的運行環境，然後用 Windows or macOS 當作作業環境 (IDE)。主要的工作配置是：</p><ol><li>VS Code runs on macOS</li><li>Application (java, golang, rust, C#) runs on Linux</li></ol><p>主要是確保應用程式的 runtime 的 development and production 是一致的。</p><p>之前注意到 <a href="https://mac.getutm.app/">UTM</a> 是因為想在 iPad Pro 上跑 Linux，但實驗後效果不如預期，所以放棄這個念頭。最近嘗試把執行環境在 Macbook Pro 上，用 UTM 跑 Ubuntu 24.04 Server，運行了差不多一個月左右，感覺還可以。過去我比較熟悉的 Virtualization 是 VMWare，連假期間順手 VMWare 兩者在 Intel 與 Apple Silicon M1 環境的效能差異。</p><span id="more"></span><h2 id="Comparsion-Matrix"><a href="#Comparsion-Matrix" class="headerlink" title="Comparsion Matrix"></a>Comparsion Matrix</h2><p>下表示這次測試的矩陣，分成硬體和軟體，共四個維度：</p><table><thead><tr><th>Virtualization \ Hardware</th><th>Intel Core (i9)</th><th>Apple Silicon (M1)</th></tr></thead><tbody><tr><td>VMWare Fusion</td><td>v</td><td>v</td></tr><tr><td>UTM</td><td>v</td><td>v</td></tr></tbody></table><p>這次測試的詳細資訊：</p><ul><li>Hardware (Host Machine):<ul><li>iMac (2020 LATE)<ul><li>Intel: 3.6 GHz 8-Core Intel Core i9</li><li>64 GB 2667 MHz DDR4</li></ul></li><li>MacBook Pro<ul><li>M1 Max</li><li>64 GB</li></ul></li></ul></li><li>Software:<ul><li>Host Machine OS: macOS 15.0.1 (24A348)</li><li><a href="https://mac.getutm.app/">UTM: Version 4.5.4 (100)</a></li><li><a href="https://www.techspot.com/downloads/2755-vmware-fusion-mac.html">VMWare Fusion: Player Version 12.2.5 (20904517)</a></li></ul></li><li>Guest OS &amp; Tools<ul><li>OS: Ubuntu 24.04 Server (Minium install)<ul><li><a href="https://ubuntu.com/download/server">x86_64</a></li><li><a href="https://ubuntu.com/download/server/arm">ARM</a></li></ul></li><li>Resources:<ul><li>CPU: 8core</li><li>memory: 16GiB</li><li>storage 80GiB SSD</li></ul></li><li>sysbeanch</li></ul></li></ul><h2 id="測試結果"><a href="#測試結果" class="headerlink" title="測試結果"></a>測試結果</h2><p>工具主要以 sysbeanch 為主，測試項目包含 CPU 速度、記憶體讀寫的 IOPS &#x2F; Throughput、磁碟的 IOPS &#x2F; Throughput</p><h3 id="Intel-Core-i9-iMac-2019-LATE"><a href="#Intel-Core-i9-iMac-2019-LATE" class="headerlink" title="Intel Core i9 (iMac 2019 LATE)"></a>Intel Core i9 (iMac 2019 LATE)</h3><p><img src="/images/Coding/Virtualization/Intel-Core-i9.png"></p><h3 id="Apple-Sillicon-M1-Macbook-Pro"><a href="#Apple-Sillicon-M1-Macbook-Pro" class="headerlink" title="Apple Sillicon M1 (Macbook Pro)"></a>Apple Sillicon M1 (Macbook Pro)</h3><p><img src="/images/Coding/Virtualization/Apple-Sillicon-M1.png"></p><p>完整的測試資料請參考 <a href="https://github.com/rickhw/open-notes/tree/main/vm">這裡</a>, 有其他像是 EC2, QNAM Virtual Station</p><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>幾個觀察到的結果：</p><ol><li>CPU 的效能：<ul><li>Apple Sillicon 跟 Intel Core i9 兩者前後差一年，CPU 效能整整差 2.75 倍。</li><li>不管是 VMWare or UTM，兩者 CPU 的效能都只有 Host Machine 的 1% 都不到，這現象值得深入了解。包含 sysbench 的測試方法，以及兩個 CPU 的虛擬化 (Virtualize) 和模擬 (Emulation) 的實作方法</li><li>不管在哪個硬體上，VMWare 的效能都比 UTM 好。</li></ul></li><li>記憶體：<ul><li>VMWare 不管在哪個硬體上，效能居然都比 Host Machine 還要好</li><li>UTM 在 Intel Core i9 (iMac) 上的記憶體效能完全不行，但在 Apple Sillicon 就跟上了</li><li>Host Machine 對比，iMac 的 DDR4-2600 居然比 Apple Sillion SoC 還要快</li></ul></li><li>Storage:<ul><li>VMWare 在 Intel Core i9 上，IOPS &#x2F; Througpht 都超過 Host Machine，在 M1 上就沒那麼好了</li><li>UTM 不管在 Intel or M1 上都很慘 …</li></ul></li></ol><hr><h2 id="個人推薦"><a href="#個人推薦" class="headerlink" title="個人推薦"></a>個人推薦</h2><p>單純以效能來看，VMWare 的效能相當不錯，但是實際上使用起來，我個人偏好使用 UTM。我的使用情境是在 Host Machine 跑 VS Code，然後 Remote to VM (Linux)。</p><p>我這個使用情境 VMWare 的 VM 跑起來後，只要電腦休眠，不管是 Macbook 盒蓋，還是 iMac 用 Sleep 的方式，下次喚醒的時候 VMWare 的網路就會從 VS Code 斷掉，然後 VS Code 連回去之後，就會重新跑新的 VS Server on Linux，但是舊的 Process 並沒有被收走。換言之，反覆幾次之後，VM 的記憶體就會被吃完。UTM 不會有這個問題，喚醒後，連線都很正常。</p><p>VMWare 還有另一個問題 (以前就有的)，不管是在 macOS or Windows 上跑的 VM，都會很容易超用指定的記憶體，開越久，暫約多。而 UTM 不會有這個現象。</p><p>上述兩者，兩者我都連續個別使用超過兩週以上觀察到的。</p><hr><h1 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h1><ul><li><a href="https://mac.getutm.app/">UTM</a></li><li><a href="https://www.techspot.com/downloads/2755-vmware-fusion-mac.html">VMWare Funsion for M1</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;我在開發時，很習慣用 Linux 當作主要的運行環境，然後用 Windows or macOS 當作作業環境 (IDE)。主要的工作配置是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;VS Code runs on macOS&lt;/li&gt;
&lt;li&gt;Application (java, golang, rust, C#) runs on Linux&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;主要是確保應用程式的 runtime 的 development and production 是一致的。&lt;/p&gt;
&lt;p&gt;之前注意到 &lt;a href=&quot;https://mac.getutm.app/&quot;&gt;UTM&lt;/a&gt; 是因為想在 iPad Pro 上跑 Linux，但實驗後效果不如預期，所以放棄這個念頭。最近嘗試把執行環境在 Macbook Pro 上，用 UTM 跑 Ubuntu 24.04 Server，運行了差不多一個月左右，感覺還可以。過去我比較熟悉的 Virtualization 是 VMWare，連假期間順手 VMWare 兩者在 Intel 與 Apple Silicon M1 環境的效能差異。&lt;/p&gt;</summary>
    
    
    
    <category term="Coding" scheme="https://rickhw.github.io/categories/Coding/"/>
    
    
    <category term="VMWare" scheme="https://rickhw.github.io/tags/VMWare/"/>
    
    <category term="Linux" scheme="https://rickhw.github.io/tags/Linux/"/>
    
    <category term="Virtualization" scheme="https://rickhw.github.io/tags/Virtualization/"/>
    
    <category term="Development Environment" scheme="https://rickhw.github.io/tags/Development-Environment/"/>
    
    <category term="Benchmark" scheme="https://rickhw.github.io/tags/Benchmark/"/>
    
  </entry>
  
  <entry>
    <title>版本定義在軟體開發過程的意義</title>
    <link href="https://rickhw.github.io/2024/09/14/SoftwareEngineering/Versioning-in-SDLC/"/>
    <id>https://rickhw.github.io/2024/09/14/SoftwareEngineering/Versioning-in-SDLC/</id>
    <published>2024-09-14T01:50:30.000Z</published>
    <updated>2025-06-27T12:21:44.305Z</updated>
    
    <content type="html"><![CDATA[<p>這篇是 <a href="https://www.facebook.com/rick.kyhwang/posts/pfbid0f6xrxJDMvAoBTDRV6cSKshmEhCpizxpdGzXtEzYpRtL9LHgUxygVg6xE6J6pZ8GPl">2022&#x2F;09&#x2F;12</a> 寫下的隨筆，主要是整理軟體版本在軟體開發團隊內部、外部的意義。</p><p>版本的概念在我的職涯生涯裡，對個人來說幾乎是常識，而且大部分 Open Source Software (OSS) 也都是這樣，如下圖。但實際上在軟體開發團隊的經驗裡，很難直接套在團隊上，因為普遍的團隊，無論怎樣的角色，對於版本是沒有概念的。</p><p><img src="/images/SoftwareEngineering/dapr-versioning.jpg"><br><img src="/images/SoftwareEngineering/dotnet-release-notes.jpg"></p><p>特別感謝 <a href="https://www.facebook.com/groups/DevOpsTaiwan/posts/5392736727479996/">DevOps 艦長 陳正瑋</a> 幫忙整理文字的摘要，如下：</p><ul><li>版本號是溝通的介面</li><li>為何需要版本號</li><li>何時決定版本號</li><li>為何需要版本號的管理原則</li><li>release 的生命週期</li><li>程式需要向下相容嗎</li></ul><p>其中，商業思維學院 院長 Gipi 也參與了討論，交換了不少想法，很有共鳴～</p><span id="more"></span><hr><h2 id="決定版本"><a href="#決定版本" class="headerlink" title="決定版本"></a>決定版本</h2><p>決定 版本 (Versioning) 的時間點：</p><ol><li>專案週期開始的時候</li><li>Release 的當下決定</li></ol><hr><h3 id="版本先決：階段開始就確立版本號碼-適合產品"><a href="#版本先決：階段開始就確立版本號碼-適合產品" class="headerlink" title="版本先決：階段開始就確立版本號碼 - 適合產品"></a>版本先決：階段開始就確立版本號碼 - 適合產品</h3><p>專案開始的時候決定版本號 (<a href="https://semver.org/">Semantic Versioning</a>，底下縮寫成 SemVer)，例如已經 Release 出去給別人用的版本是 <code>3.2.0</code>，而接下來要開發的是 <code>3.3.0</code>，改變的是第二碼。</p><p>這種開發流程，對於版本號碼是有很高的靈敏度，而版本號也是開發過程，團隊對內對外主要的溝通介面。</p><p>版本號通常在專案階段性的開始，由 Product Manager 宣告版本號碼，接下來要開發的版本號碼是 3.3.0 (有時候也會用代號)，然後改動 Source Code 裡面關鍵的版本編號檔，發動第一次的 Build 流程，代表下一個開發週期開始。</p><p>而已經 release 出去的版本，就代表著要做 <code>客戶關係管理 (CRM)</code>，也就是用版本先跟客戶對焦，確立問題的基礎點。通常為了避免內部資源耗盡，都會定義 LTS (Long Term Support) Version，通常不會同時有三個版本以上。 (我以前維護過 4 個 @@</p><p>大部分具規模的 Open Source 都是這種跑法，像是 K8s, Dapr, .NET, Linux, Ubuntu … 或者開發給別人使用的 <code>工具 (被依賴)</code>，就像像是 Lib &#x2F; SDK &#x2F; Tools &#x2F; CLI &#x2F; API … 也都適合這種方法。</p><h3 id="版本後決：上線前決定-適合專案"><a href="#版本後決：上線前決定-適合專案" class="headerlink" title="版本後決：上線前決定 - 適合專案"></a>版本後決：上線前決定 - 適合專案</h3><p>第二種屬於 Release 當下才知道版本，也就是 <code>專案完成決定版本</code>，通常屬於沒有被依賴、快速迭代的專案。</p><p>像是直接對外的 Web Site (有前端)，版本通常不會是必要的資訊，仰賴自動化標記版本號碼。實際的作法像是 commit 後的 hook 或者 gitops，依照規則自動打上版號，或者 timestamp，或者自動計算 SemVer。規則可以是 tag event、merge event、特定的 branch、特定的 branch naming role … 等。</p><p>這種案例比較好的做法也應該是走 SemVer，特別是 Single Code Base、Multiple Deployment 的時候，這樣才能確保 Single 的唯一性，也就是不同的部署，都是同一個 (Artifacts)。</p><p>概念就是同樣都是 Windows 11，大家裝的應該都是透過同一個 Image 安裝的，換言之也應該 專案開始決定版本 的做法</p><hr><h2 id="現象探討"><a href="#現象探討" class="headerlink" title="現象探討"></a>現象探討</h2><h3 id="版本後決衍生的現象-缺乏統一的溝通基礎"><a href="#版本後決衍生的現象-缺乏統一的溝通基礎" class="headerlink" title="版本後決衍生的現象 - 缺乏統一的溝通基礎"></a>版本後決衍生的現象 - 缺乏統一的溝通基礎</h3><p><code>版本後決</code> 通常會衍伸以下現象：</p><ol><li>版本本身沒有啥意義，因為大家不會拿來溝通</li><li>團隊各種角色 (P&#x2F;D&#x2F;Q&#x2F;O)，普遍都不知道現在版本是多少</li><li>各種角色的溝通沒有 Baseline<ul><li>Dev 會用各種技術手段自動化版號的更動，像是用 Timestamp 取代 SemVer、或者改動 SemVer 規則，像是三碼變兩碼、兩碼變一碼。總之，能動就好。</li><li>PM&#x2F;PO 通常也不會在乎，通常這都是產品&#x2F;專案規劃的問題，也是判斷軟體的產品經理是否具備專業度的指標之一。</li><li>其他角色 QA &#x2F; Ops 也不知道 Dev 在做啥。</li></ul></li></ol><p>換言之，溝通沒有一個標準的介面點，如果同一個版本布署到很多環境，其實沒有人能知道，這些環境用的版本是否是同一個 Artifact。所以通常沒有版本概念的團隊，也不太會有 Artifact 的概念，衍伸的問題則是蓋環境困難度很高 (Provisioning)。</p><p>團隊裡各個角色溝通的介面是模糊的，不是具體的介面。</p><p>通常這樣的團隊，QA 的測試往往沒有基礎點 (BaseLine)，換言之，常常會測到一半，版本就變了，但是沒人知道 (Dev &#x2F; QA 都不知道)</p><p>比較理想的測試基礎就是基於 Artifact，透過 Artifact 上的版本資訊，做驗證以及後續問題的討論與溝通。</p><h3 id="版本的用途是什麼？-溝通"><a href="#版本的用途是什麼？-溝通" class="headerlink" title="版本的用途是什麼？ - 溝通"></a>版本的用途是什麼？ - 溝通</h3><p>在軟體開發中，版本主要有幾個很重要的用途：</p><ol><li><code>溝通的標準介面</code>: 不管是怎樣的角色 (PM &#x2F; Dev &#x2F; QA &#x2F; Ops) 都是透過 版本溝通，以這為起點，才知道現在溝通的 base line 是什麼</li><li><code>產品的階段性</code>: 版本本身代表階段性功能的集合，例如 Windows 11 一定會有 “一堆 New Features”，這也牽涉 PO &#x2F; PM 對於階段性定義的掌握與佈局</li><li><code>持續迭代</code>: 版本本身就具備迭代概念，特別是 SemVer 就是個持續改善的定義</li></ol><p>版本背後也隱含：</p><ol><li><code>明確有哪些功能</code>: 例如 6.0 有一堆新功能 A, B, C, D，6.1 多了 E 功能。 … etc.</li><li><code>明確迭代的節奏</code>: 有週期性、有 LTS .</li><li><code>可以比較新舊差異</code>: 比較就是有新功能，有舊功能，才有辦法做 Migration Plan，或者告訴客戶應該怎麼應變。</li></ol><p>上述都仰賴團隊一起努力做好專案管理與產品規劃。</p><h3 id="在軟體開發過程，為什麼會缺乏版本？"><a href="#在軟體開發過程，為什麼會缺乏版本？" class="headerlink" title="在軟體開發過程，為什麼會缺乏版本？"></a>在軟體開發過程，為什麼會缺乏版本？</h3><p>沒有版本概念的肇因：</p><ol><li>缺乏全局角度的觀點，也就是從客戶角度思考產品</li><li>沒有溝通的標準介面定義，通常是專案管理的問題</li><li>為了自動化而自動化，只知道 commit 後會動 (ex: gitops) 就好</li></ol><p>普遍是為了自動而自動，工具都是為了輔助流程，<code>主、次</code> 應該是 <code>標準程序</code> 是 <code>主</code>，透過工具 (自動化) 滿足標準程序，工具 (自動化) 是 <code>次</code>。</p><!--## 軟體團隊開發，版本管理的常見問題### 問題：內外不一致的版本 - 開發工程師有自己內部的版本、PM 有自己對外的版本### 問題：同一個產品底下的模組版本是否一致的問題--><p><img src="/images/SoftwareEngineering/SemanticVersioning/bytebytego_semantic-versioning.png"></p><hr><h2 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h2><ul><li><a href="/2017/11/12/DevOps/Gossip-Automation/">自動化帶來的問題</a></li><li><a href="/2022/04/06/SoftwareEngineering/Artifact-Management-and-Version-Control/">Version Control 與 Artifact Management</a></li><li><a href="/2015/02/11/SoftwareEngineering/Version-Control/">Version Control</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;這篇是 &lt;a href=&quot;https://www.facebook.com/rick.kyhwang/posts/pfbid0f6xrxJDMvAoBTDRV6cSKshmEhCpizxpdGzXtEzYpRtL9LHgUxygVg6xE6J6pZ8GPl&quot;&gt;2022&amp;#x2F;09&amp;#x2F;12&lt;/a&gt; 寫下的隨筆，主要是整理軟體版本在軟體開發團隊內部、外部的意義。&lt;/p&gt;
&lt;p&gt;版本的概念在我的職涯生涯裡，對個人來說幾乎是常識，而且大部分 Open Source Software (OSS) 也都是這樣，如下圖。但實際上在軟體開發團隊的經驗裡，很難直接套在團隊上，因為普遍的團隊，無論怎樣的角色，對於版本是沒有概念的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/SoftwareEngineering/dapr-versioning.jpg&quot;&gt;&lt;br&gt;&lt;img src=&quot;/images/SoftwareEngineering/dotnet-release-notes.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;特別感謝 &lt;a href=&quot;https://www.facebook.com/groups/DevOpsTaiwan/posts/5392736727479996/&quot;&gt;DevOps 艦長 陳正瑋&lt;/a&gt; 幫忙整理文字的摘要，如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;版本號是溝通的介面&lt;/li&gt;
&lt;li&gt;為何需要版本號&lt;/li&gt;
&lt;li&gt;何時決定版本號&lt;/li&gt;
&lt;li&gt;為何需要版本號的管理原則&lt;/li&gt;
&lt;li&gt;release 的生命週期&lt;/li&gt;
&lt;li&gt;程式需要向下相容嗎&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中，商業思維學院 院長 Gipi 也參與了討論，交換了不少想法，很有共鳴～&lt;/p&gt;</summary>
    
    
    
    <category term="Software Engineering" scheme="https://rickhw.github.io/categories/Software-Engineering/"/>
    
    
    <category term="Artifact Management" scheme="https://rickhw.github.io/tags/Artifact-Management/"/>
    
    <category term="Version Control" scheme="https://rickhw.github.io/tags/Version-Control/"/>
    
    <category term="Semantic Versioning" scheme="https://rickhw.github.io/tags/Semantic-Versioning/"/>
    
    <category term="SDLC" scheme="https://rickhw.github.io/tags/SDLC/"/>
    
  </entry>
  
  <entry>
    <title>聊聊 Code Generator (for Productivity and Quality)</title>
    <link href="https://rickhw.github.io/2024/09/07/Coding/Codegen-for-Productivity-and-Quality/"/>
    <id>https://rickhw.github.io/2024/09/07/Coding/Codegen-for-Productivity-and-Quality/</id>
    <published>2024-09-06T19:33:00.000Z</published>
    <updated>2025-06-27T12:21:44.310Z</updated>
    
    <content type="html"><![CDATA[<p>這篇是我在 <a href="https://www.facebook.com/rick.kyhwang/posts/pfbid02FD5nDLcNkpH2c7dDEh6iKJheZgswXhyzn3rFSBx82PB2p5T7FGPwFfHx7aya8Cnal">2023&#x2F;09&#x2F;07</a> 聊到關於 Code Generator (底下簡稱 codegen or CodeGen) 的經驗與想法。</p><span id="more"></span><hr><h2 id="Codegen-經驗談"><a href="#Codegen-經驗談" class="headerlink" title="Codegen 經驗談"></a>Codegen 經驗談</h2><h3 id="2008-codegen-banking-system-design-patterns"><a href="#2008-codegen-banking-system-design-patterns" class="headerlink" title="2008: codegen banking system design patterns"></a>2008: codegen banking system design patterns</h3><p>我大約 2008 一個案子開始接觸 codegen，從一開始我就很喜歡這個模式，因為生產力很高。可以透過這樣的方法快速產生 project template (Java Project using EJB for eclipse project)、design pattern for best practice，然後執行各項 Unit Test. 下圖則是當時用 CodeGen 產生後，執行 UT 的紀錄：</p><p><img src="/images/Coding/CodeGen/Codegen-experience-2008-banking.jpg"></p><h3 id="2010-codegen-for-automation-test"><a href="#2010-codegen-for-automation-test" class="headerlink" title="2010: codegen for automation test"></a>2010: codegen for automation test</h3><p><a href="/2018/05/12/SQA/Designing-Test-Architecture-and-Framework/">Designing Test Architecture and Framework</a> 一文分享了過去設計 Automation Test Framework 的紀錄，主要都在討論框架怎麼設計，以及流程面。不過其中沒提到的就是如何寫 Test Case，這個過程也是用 Codegen 產生標準的 Test Case 框架，讓 QA &#x2F; Tester 依照標準框架開發，包含 Config &#x2F; Data &#x2F; Log 等。</p><h3 id="2012-codegen-improves-ORM-productivity"><a href="#2012-codegen-improves-ORM-productivity" class="headerlink" title="2012: codegen improves ORM productivity"></a>2012: codegen improves ORM productivity</h3><p>類似的概念，也用在我自己曾經開發過的 ORM (背後設計想法有點像 MyBatis)。那個時候大部分主流的 ORM (MyBatis &#x2F; Hibernate) 還是要寫一些基本的東西，像是 repostory、VO、entity … etc。</p><p>但我實在很懶得再寫這堆重複性很高的東西，所以整個設計就是直接把傳統 ORM 要做的雜事，用 CodeGen 直接產生。實作概念是直接掃描整個 database，用 codegen 直接產生出整個 ORM 的 skeleton，也就是 用 java 產生出 java，整個生產力非常高。下圖則是用這個 ORM 開發的 app … 主要是用來管理一堆 Server Rack 的管理介面。</p><p><img src="/images/Coding/CodeGen/Codegen-ORM_2012.jpg"></p><p>這個做法讓我很專注在設計 Database Schema 以及處理 Service Layer 的商業邏輯，省去很多時間處理 ORM 中間的重複性很高的任務。</p><h3 id="API-First"><a href="#API-First" class="headerlink" title="API First"></a>API First</h3><p>除了上述的應用場景，另一個 CodeGen 用很多的地方是導入 API First 的過程。</p><p>OpenAPI 的規格 swagger.yaml 可以透過設計優先 (Design First) 的概念，先完成規格的設計，透過 CodeGen 產生出對應程式語言的 RESTful skeleton，這個 skeleton 會依據 Spec 描述的 Data Model 產生對應的程式碼，同時也完成一些基本的處理，像是 Data Validation、Response 等，而開發者只要專注在商業邏輯的處理即可。</p><p>API First 背後的精神都在於 Spec 是否完善，後面才會跟著完善。</p><h2 id="Objective-and-Key-Result"><a href="#Objective-and-Key-Result" class="headerlink" title="Objective and Key Result"></a>Objective and Key Result</h2><p>做每一件事情，背後都有其動機，CodeGen 最重要的目的 (Objective) 是：</p><blockquote><p>提高開發 <code>生產力 (Productivity)</code> 與 <code>品質 (Quality)</code></p></blockquote><p>這個目的背後更具體的就是標準化開發過程所共同 (Common) 的東西，像是 Log &#x2F; Config &#x2F; Security &#x2F; Coding Style … 等 標準化，而這些標準化的工作其實就是 <code>Internal Developer Platform (IDP)</code> 的基本工作之一。</p><blockquote><p>更多關於 IDP 參閱個人著作：<a href="/2023/07/17/About/2023-SRE-Practice-and-IDP/">個人著作《SRE 實踐與開發平台指南》</a></p></blockquote><h2 id="導入的問題"><a href="#導入的問題" class="headerlink" title="導入的問題"></a>導入的問題</h2><p>codegen 概念對我個人來講，算是很熟捻的東西，包含怎麼活用、怎麼提升產能、或者降低開發過程的一致性問題 ..</p><p>不過在工作中導入，也遇過一些問題，像是:</p><ul><li>被嗆說這種東西是一次性的，沒啥屁用</li><li>這種東西大多都失敗，不要浪費時間</li></ul><p>這兩個問題的源頭都不在技術本身，在於用的人懂不懂軟體工程 …</p><p>所有的 IDE 在 create project 的原理就是 codegen，所有 open source 網站上文件的 reference part，都是 codegen，一些 SDK for multiple languages 也都是 codegen，然後 MVC 的 View 本質上就是 codegen …</p><p><code>軟體工程</code> 的價值 在於:</p><ol><li>reusable (可重複使用，提高開發生產力、品質)</li><li>scalable (可拓展業務)</li></ol><p>codegen is 1) for most of cases, for advanced case, such as #IDP, is 2)</p><h2 id="一些想法"><a href="#一些想法" class="headerlink" title="一些想法"></a>一些想法</h2><p>判斷一家公司是否是上軌道的軟體公司，不是用規模或人數來判斷，反而是可以從以下過程的速度當指標：</p><blockquote><p>idea -&gt; poc -&gt; MVP</p></blockquote><p>這個過程的速度有多快，就是軟體開發成熟度的指標。</p><p>而且 MVP 出來的東西要符合公司既定開發政策，像是 metadata、logging、config、security、coding conversion … 等老生常談的 <code>guideline</code> 或者 <code>discipline (紀律)</code> ，而這些都是 codegen 可以直接秒殺的東西，只要有持續迭代。</p><p>如果每個團隊都還要重新理解、自己寫、或者問要遵守哪一套，那有兩個問題是要留意的：</p><ol><li>管理與治理 - 管理團隊的管理能力</li><li>軟體工程的能力 - 專業團隊的專業能力與專業素養</li></ol><p>如果要做 <code>Platform Engineering</code>, or <code>Internal Developer Platform (IDP)</code>，Codegen 是直接呈現產能最直接的方式，否則一堆規範 &#x2F; 制度 &#x2F; 紀律 …. 都只是紙上談兵的東西。</p><h2 id="AI"><a href="#AI" class="headerlink" title="AI"></a>AI</h2><p>AI 已經是趨勢，而可以 CodeGen 代表背後要被 AI 直接產生就更簡單了，也代表 AI 其實可以直接透過其他動態的方式，完成 CodeGen 的任務。</p><hr><h1 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h1><ul><li><a href="/2022/05/06/Coding/Designing-Configuration-Loading-Strategies/">Designing Configuration Loading Strategies</a></li><li><a href="/2018/05/12/SQA/Designing-Test-Architecture-and-Framework/">Designing Test Architecture and Framework</a></li><li><a href="/2023/07/17/About/2023-SRE-Practice-and-IDP/">個人著作《SRE 實踐與開發平台指南》</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;這篇是我在 &lt;a href=&quot;https://www.facebook.com/rick.kyhwang/posts/pfbid02FD5nDLcNkpH2c7dDEh6iKJheZgswXhyzn3rFSBx82PB2p5T7FGPwFfHx7aya8Cnal&quot;&gt;2023&amp;#x2F;09&amp;#x2F;07&lt;/a&gt; 聊到關於 Code Generator (底下簡稱 codegen or CodeGen) 的經驗與想法。&lt;/p&gt;</summary>
    
    
    
    <category term="Coding" scheme="https://rickhw.github.io/categories/Coding/"/>
    
    
    <category term="Platform Engineering" scheme="https://rickhw.github.io/tags/Platform-Engineering/"/>
    
    <category term="Internal Developer Platform" scheme="https://rickhw.github.io/tags/Internal-Developer-Platform/"/>
    
    <category term="Code Generator" scheme="https://rickhw.github.io/tags/Code-Generator/"/>
    
    <category term="Template" scheme="https://rickhw.github.io/tags/Template/"/>
    
    <category term="Productivity" scheme="https://rickhw.github.io/tags/Productivity/"/>
    
    <category term="Quality" scheme="https://rickhw.github.io/tags/Quality/"/>
    
    <category term="API First" scheme="https://rickhw.github.io/tags/API-First/"/>
    
  </entry>
  
  <entry>
    <title>系統思維 - 好組織的三個特徵</title>
    <link href="https://rickhw.github.io/2024/06/15/Management/Self-Orgnization/"/>
    <id>https://rickhw.github.io/2024/06/15/Management/Self-Orgnization/</id>
    <published>2024-06-15T14:50:30.000Z</published>
    <updated>2025-10-20T12:58:24.853Z</updated>
    
    <content type="html"><![CDATA[<p>整理自 <a href="https://www.facebook.com/rick.kyhwang/posts/pfbid0N2pD7AJiFUExosR9cLCE5P9bpq1Zg5ddkS8KUVEkjXwcYe4fnftyr15t5PkcNDGtl">FB 20200615</a> 的隨筆，針對底下這段話的延續探討：</p><blockquote><p>系統思維好系統有三個特徵：抗打擊、自組織、以及中央控制和子系統自治要有一個平衡關係 —— 這三個特徵明顯更符合生態系統的特徵。</p></blockquote><p>這些三點，背後有各自的問題與實際案例。</p><span id="more"></span><hr><p>這三點：</p><ol><li>抗打擊</li><li>自組織</li><li>中央控制和子系統要有平衡關係</li></ol><p>這三點提到的概念，與 <a href="https://www.jeremiahlee.com/posts/failed-squad-goals/">Spotify 的組織為啥失敗</a> 這篇比較，我覺得 Spotify 主因在於：</p><h2 id="1-中央和地方沒有維持平衡關係"><a href="#1-中央和地方沒有維持平衡關係" class="headerlink" title="1. 中央和地方沒有維持平衡關係"></a>1. 中央和地方沒有維持平衡關係</h2><p>現象就兩種，第一是 <code>過度中央集權，地方無法參與決策</code>。</p><p>中央說了算，地方做就對了。中央容易自我感覺良好，地方久了地方失去思考能力，只會等指令 …. 地方有想法的人很容易因為跟中央有衝突，很容易就想換工作，因為中央容不下地方的想法。通常這種公司就是很會做行銷，到處發新聞稿，營造一片祥和的樣子，但是去 ptt 會看到一堆員工在幹樵。</p><p>第二個則是 <code>地方反過來壓制中央</code>，現象就是：整家公司步伐目標不一致，長出很多奇怪的產品線，內部溝通混亂、內部很容易一直重新造輪子，最後就分家了。厲害的人，很容易就跑了，甚至自己創業開新戰線。</p><p>當中央與地方不平衡，處理政治問題就飽了。</p><h2 id="2-沒有定義好跨團隊溝通的協議"><a href="#2-沒有定義好跨團隊溝通的協議" class="headerlink" title="2. 沒有定義好跨團隊溝通的協議"></a>2. 沒有定義好跨團隊溝通的協議</h2><p>地方要怎樣就怎樣，中央不知道要管、或者沒有方法可以管理、對治理沒概念。地方不管中央的決策、或者不理會中央的政策，只想趕時程。現象：歪樓、發散、衝突不斷，無法管理、失控。</p><p>中央有定義溝通協議，但是太過冗長，沒有效率，或者訂了很漂亮的協議，但是不知道怎麼落地，像是某 CMMI … 這種就是最常被敏捷派幹樵的點。現象：Blocking I&#x2F;O …. 地方變成懶散、士氣低落。如果公司要撐下去，要靠那群首腦撐，通常都退不了休，白髮蒼蒼，找不到接班人。</p><h2 id="3-為所欲為的自組織"><a href="#3-為所欲為的自組織" class="headerlink" title="3. 為所欲為的自組織"></a>3. 為所欲為的自組織</h2><p>自組織不是為所欲為，而是要遵循一定的程序與章法做事。</p><p>技術單位通常的問題就是自組織的 <code>技術管理</code>。</p><p>用什麼技術選型？解決什麼問題？如何導入某一個新技術？如何訓練？如何養成？如何找到市場上熟悉該技術的人才？技術普及程度？技術的未來性？ … 等，都是技術管理課題。自組織不是今天開心用 Node.JS、明天用 Python、後天用 Golang …. 今天用 AWS 、明天用 GCP … 用了三四套 RDBMS … 這些都是技術管理課題，都是要有章法、有程序的。自組織，不是要怎樣就怎樣，更不是為所欲為。</p><p>溝通也要有遵循一定準則，特別是跨團隊協作。像是：</p><ol><li><a href="https://www.facebook.com/photo.php?fbid=10213674734102033&set=a.4018937451224&type=3">開會原則</a></li><li><code>溝通共識</code>: 文件管理 &#x2F; KM -&gt; 請參考 <a href="https://rickhw.github.io/2019/01/21/Management/KM-and-Issue-Tracking/">我的廢文</a></li></ol><p>花蓮市不是直轄市，新北市是直轄市。花蓮市要升格要有條件，不是因為地方自治，就可以隨意升格、招兵成立軍隊。花蓮市長找台北市長開會，要照規矩的，不是車開著就北上去了，什麼都沒通知的。</p><p>一切都還是有規矩的。</p><hr><p>回到一開始提的：</p><ol><li>抗打擊</li><li>自組織</li><li>中央控制和子系統要有平衡關係</li></ol><p>這些概念很簡單，就跟一個國家的治理一樣。</p><p>台北市雖然是直轄市，但不能自己招募軍隊，因為軍隊是中央的。中央要定義遊戲規則，讓地方遵循，地方覺得規則有意見，要透過溝通管道上述溝通，否則算是政變。</p><p>三國演義就是中央無力管理地方，造成地方拿到軍權，開始反制中央，最後變成大亂鬥的局勢。客氣一點的，就夾天子以令諸侯，不要臉一點就是自稱皇叔、不然就從哥哥那裡繼承權利過來。。。我到底在說殺小</p><p>所有的問題就是： <code>溝通沒做到位</code></p><blockquote><p>翻譯：該摸頭沒摸到、該給糖的沒有給</p></blockquote><p>自組織問題、溝通問題、結構問題沒有處理，當 <code>亂</code> 到一定程度，就會變成 <code>難</code>, 大概就像<a href="https://www.facebook.com/rick.kyhwang/posts/10212065783919284">這篇</a> 寫的樣子。</p><hr><h2 id="相關文章"><a href="#相關文章" class="headerlink" title="相關文章"></a>相關文章</h2><ul><li><a href="https://www.jeremiahlee.com/posts/failed-squad-goals/">Spotify 的組織為啥失敗</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;整理自 &lt;a href=&quot;https://www.facebook.com/rick.kyhwang/posts/pfbid0N2pD7AJiFUExosR9cLCE5P9bpq1Zg5ddkS8KUVEkjXwcYe4fnftyr15t5PkcNDGtl&quot;&gt;FB 20200615&lt;/a&gt; 的隨筆，針對底下這段話的延續探討：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;系統思維好系統有三個特徵：抗打擊、自組織、以及中央控制和子系統自治要有一個平衡關係 —— 這三個特徵明顯更符合生態系統的特徵。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;這些三點，背後有各自的問題與實際案例。&lt;/p&gt;</summary>
    
    
    
    <category term="經營管理" scheme="https://rickhw.github.io/categories/%E7%B6%93%E7%87%9F%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="System Thinking" scheme="https://rickhw.github.io/tags/System-Thinking/"/>
    
    <category term="系統思維" scheme="https://rickhw.github.io/tags/%E7%B3%BB%E7%B5%B1%E6%80%9D%E7%B6%AD/"/>
    
  </entry>
  
  <entry>
    <title>Identifier Design Consideration</title>
    <link href="https://rickhw.github.io/2024/03/24/Design/Identifiers-Design-Consideration/"/>
    <id>https://rickhw.github.io/2024/03/24/Design/Identifiers-Design-Consideration/</id>
    <published>2024-03-24T05:30:00.000Z</published>
    <updated>2025-06-27T12:21:44.235Z</updated>
    
    <content type="html"><![CDATA[<p>整理一些設計 Identifier 要考慮的事情，特別是要揭露給使用者的時候，像是 RESTful API 的設計。原文來自 <a href="https://www.facebook.com/rick.kyhwang/posts/pfbid02Kjy4HJRmN5HT2vtyno5p5pGHbbLdNYQR1QTRStqK4tj9CveE3TbxhnNiVtJ9YyCrl">facebook</a> 寫的草稿。</p><span id="more"></span><hr><h1 id="Consideration"><a href="#Consideration" class="headerlink" title="Consideration"></a>Consideration</h1><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>Identifier (經常縮寫成 Id or ID)，本質就是 <code>識別</code>，用來找到特定的資源 &#x2F; 物件，在系統中具備 <code>唯一性 (Unique)</code>。</p><p>生活中常見的例子：</p><ol><li>身分證字號：用於識別個人身份，是各國政府機構核發的獨特識別碼。</li><li>產品編號：用於識別產品，通常由製造商分配，有助於追蹤產品的製造和銷售情況。</li><li>網域名稱 (DNS)： 用於識別網路上的各種資源，例如網站、郵件伺服器等。</li><li>IP Address：用於識別網路上的設備，是通訊協定中的一個重要元素。</li><li>手機 IMEI 碼：用於識別手機設備，有助於防止偷竊和盜版。</li><li>電商的訂單：訂單編號、取貨號碼</li></ol><hr><h2 id="適用範圍-Scope"><a href="#適用範圍-Scope" class="headerlink" title="適用範圍 (Scope)"></a>適用範圍 (Scope)</h2><p>前面一段舉例很多例子，但實際上 Id 都有適用範圍。</p><ol><li><code>身分證字號</code>：適用範圍是國家之內，如果是護照號碼，範圍就是全球。</li><li><code>產品編號</code>：適用範圍就是生產公司的範圍。</li><li><code>IP Address</code>：以 IPv4 而言，本身就有區分 保留 (Private | Broadcast) &#x2F; 公有 (Public)  … 等，Public 就是全球範圍網域 (WAN)、私有就是私有網域 (LAN) …</li><li><code>登入帳號</code>：App 登入的帳號本身則是看使用 SSO 還是 Local，就可以區分範圍。</li></ol><p>用 <code>EC2 Instance Id</code> 當例子，EC2 InstanceId 的設計是為了 <code>可程式化 (Programmable)</code>，具備全局的唯一性 (Global Unique)。也就是每個 InstanceId，不管是在哪一個 AWS Region or Zone、或者跨 AWS Account，都是唯一的 Id，而且不可重複使用。詳細參閱 <a href="https://repost.aws/questions/QUo8PH97hlS0KwUx5tNIc4JQ/instance-id-uniqueness">Instance ID uniqueness</a></p><p><img src="/images/Design/Scope-of-InstanceId_v20240322.png"></p><!--source: https://docs.google.com/presentation/d/1RYkfxwCMhCTqzgoWLlxHNJHbVL19pttPaixwxEtjhLM/edit#slide=id.g2c5e8398b8e_0_9--><p>程式語言裡的變數可以當作一種 id，範圍有 <code>global variable</code> or <code>local variable</code>。當名稱衝突的時候，依照程式語言的設計，可能會有不同層度的錯誤或者警告。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>name = <span class="string">&quot;rick&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">getName</span>():</span><br><span class="line"><span class="meta">... </span>    name = <span class="string">&quot;jack&quot;</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> name</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(name)</span><br><span class="line">rick</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getName()</span><br><span class="line"><span class="string">&#x27;jack&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="縮小範圍"><a href="#縮小範圍" class="headerlink" title="縮小範圍"></a>縮小範圍</h3><p>電商為例，訂單編號本身是個全域變數，是電商系統的在看的，不管有怎麼好的設計、編碼規則，單一個編號通常會很長。</p><p>設計時要讓使用者可以快速定位，基本的做法就是改變範圍，所以現在很常用的縮小範圍就是：</p><ol><li><code>區域範圍</code>：一家超商能放的商品數量多則上百件、少則數十件</li><li><code>反向檢索</code>：透過使用者的手機末幾碼，反向索引編號。因為訂單編號是電商系統產生的，本質上跟使用者示弱關聯，取貨的是使用者，用一個弱關聯的號碼讓使用者取貨，是不好的使用體驗。所以反向的用使用者的電話號碼或者身分證末幾碼，可以達到同樣效果，同時可以快速過濾。</li></ol><hr><h2 id="可數-與-不可數"><a href="#可數-與-不可數" class="headerlink" title="可數 與 不可數"></a><code>可數</code> 與 <code>不可數</code></h2><p>這概念跟英文的 <code>可數</code> &#x2F; <code>不可數</code>、數學上的 <code>窮舉法 (Proof by exhaustion)</code>、程式語言的 <code>迴圈 (for)</code>、<code>white / iterate (迭代器)</code> … 等概念是一樣的。</p><p>Id 的數量會很多，通常會歸類成不可數，像是：</p><ol><li>每隻手機 <code>IMEI</code> 碼：代表這只手機的唯一性與合法性。但手機的數量很多，基本上發展到現在已經數量多到不知道怎麼數了 …<ul><li>可以透過 <code>*#06#</code> 查到</li></ul></li><li>電腦網卡的位址 (Mac Address)</li><li>全球的網頁數</li><li>地球的沙子</li></ol><p>可數的 Id 相對於不可數的是比較少，數量級大概會少於 100 以內，比較多的會是 1000 以內，不管怎樣，會 <code>有明確上限</code>，可以 <code>正面表列</code>、<code>列舉清單</code> 。像是：</p><ol><li>台灣郵遞區號</li><li>國際電話號碼的前幾碼</li><li>AWS region 代號</li></ol><p>可討論：</p><ul><li>電腦的編碼系統 (<a href="https://en.wikipedia.org/wiki/Unicode">Unicode</a>) 嚴格講是個可數系統，因為字元 (character) 會直接正面表列被定義，像是英數字的數量、雙位元語系數量 (中日韓)、後來定義的 emoji 等符號。不過 Unicode 的數量很大，版本 15.1 共定義了 <code>149,813</code> 個字元。</li></ul><p>設計系統的時候，要稍微思考一下，這個東西的數量級是可數 or 不可數。</p><p>可數有點像是 <code>寵物</code> ，不可數像是 <code>畜生</code> 來想，更多參閱 <a href="https://www.hava.io/blog/cattle-vs-pets-devops-explained">Cattle vs Pets | DevOps Explained</a></p><hr><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p>設計 Id 最多人討論的是格式 (Format &#x2F; Pattern)，格式要考慮的有幾點：</p><ol><li><code>數量級 (scale)</code>：可數 (countable)、不可數 (uncountable)</li><li><code>理解性 (understandability)</code>：可理解、部分理解、完全不可理解</li></ol><p>這樣的設計角度，會有以下六種排列組合的設計思路：</p><p><img src="/images/Design/Countable-Understandability.png"></p><!--source: https://docs.google.com/presentation/d/1RYkfxwCMhCTqzgoWLlxHNJHbVL19pttPaixwxEtjhLM/edit#slide=id.p--><h3 id="A1-可數-可讀性"><a href="#A1-可數-可讀性" class="headerlink" title="A1 可數 + 可讀性"></a>A1 可數 + 可讀性</h3><p>可數 代表數量極有限，數量 &lt;&#x3D; 100 or 1000，通常會搭配 <code>可讀性設計原則</code>，也就是定義一個命名規則，讓我們使用上可以一目瞭然。</p><p>幾個來自 AWS 的經典例子：</p><ol><li><code>region code</code>: ap-northeast-1, us-east-1, us-west-2 … etc，詳細參閱 <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html">Regions and Zones</a></li><li><code>EC2 Instance Type</code>: t2.small, c5.large, r5.xlarge … etc，詳細參閱 <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html">Instance types</a></li><li><code>Security Group Name</code>: 允許使用者輸入一段自己定義的名稱，<a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules.html">官方文件說明</a>，命名規則可以參閱我的設計：<a href="/2017/07/07/AWS/Plan-And-Deisgn-Multiple-VPCs-in-Different-Regions/">Plan and Design Multiple VPCs in Different Regions</a></li></ol><p>這類通常在程式語言或者 API，都會直接用 <code>enum</code> 的方式列舉。</p><h3 id="A2-可數-部分理解"><a href="#A2-可數-部分理解" class="headerlink" title="A2: 可數 + 部分理解"></a>A2: 可數 + 部分理解</h3><p>可數 可以搭配固定理解的組合，像是：</p><ol><li>系統 Log 的 ErrorCode：<code>E10-03</code> 這樣代表一個錯誤訊息， 有個編碼 <code>[IEW][0-1]&#123;2&#125;-[0-1]&#123;2&#125;</code> 這樣的規則….</li><li>台灣身分證字號：規則可以參閱 <a href="https://magiclen.org/tw-id-num/">如何寫程式處理中華民國的身份證字號？</a>, <a href="https://crates.io/crates/tw-id-num">Rust 實作</a></li><li><code>HTTP Status Code</code>：5XX, 4XX … 等，可數、有明確上限</li></ol><h3 id="A3-可數-完全不可理解"><a href="#A3-可數-完全不可理解" class="headerlink" title="A3: 可數 + 完全不可理解"></a>A3: 可數 + 完全不可理解</h3><p>可數 + 完全不可理解 這個組合比較少用，我會用在資訊敏感的，卻要對外直接揭露的，像是企業內部對外 egress 的節點。</p><blockquote><p>實際上有些公司對外的 egress 可能是不可數的 XDD</p></blockquote><h3 id="B1-不可數-可讀性"><a href="#B1-不可數-可讀性" class="headerlink" title="B1: 不可數 + 可讀性"></a>B1: 不可數 + 可讀性</h3><p>不可數 + 可讀性：這個設計沒啥意義，但是工程師喜歡挑戰這種東西，像是 …. docker container 的 random name …</p><h3 id="B2-不可數-部分理解"><a href="#B2-不可數-部分理解" class="headerlink" title="B2: 不可數 + 部分理解"></a>B2: 不可數 + 部分理解</h3><p>不可數 + 部分理解，這其實跟 可數 + 部分理解 是類似的概念。</p><p>最經典的例子是 UUID 的設計，基本上就是懶人設計。</p><p>另外一個很常見的應用案例，AWS 的 resourceId (insanceId, vpc id, ebs id … etc) 都是這種設計.</p><p>著名的專案管理系統 JIRA 的 Issue number 可以前綴專案代號，也是一樣的概念。</p><h3 id="B3-不可數-不可理解"><a href="#B3-不可數-不可理解" class="headerlink" title="B3 不可數 + 不可理解"></a>B3 不可數 + 不可理解</h3><p>不可數 + 完全不可理解，不知道 UUID 結構的會把它擺這裡。。。基本上這個設計大概就是個只想要一個唯一就好的設計，內容是啥完全不想管。。。像是 MySQL 常用的 auto-increment。</p><p>上述六種排列組合，整理常見範例如下表：</p><p><img src="/images/Design/Countable-Understandability-Example_v20240322.png"></p><h3 id="實作與-API-設計"><a href="#實作與-API-設計" class="headerlink" title="實作與 API 設計"></a>實作與 API 設計</h3><p>可數的 Id 通常在程式語言或者 API 參數，都會直接用 <code>enum</code> 的方式列舉，也就是透過列表方式呈現給使用者查詢。</p><p>不可數的 Id 則轉化成 API 讓使用者自行查詢。</p><hr><h1 id="常見問題"><a href="#常見問題" class="headerlink" title="常見問題"></a>常見問題</h1><h2 id="Q-Id-碰撞"><a href="#Q-Id-碰撞" class="headerlink" title="Q: Id 碰撞"></a>Q: Id 碰撞</h2><p>通常是使用不適當的屬性作為 Id，像是電腦的 hostname 當作唯一個識別，這個例子在 Windows 體系的 Active Directory (AD) 很常見。</p><p>解法的邏輯就是透過 <code>限縮範圍</code>、<code>亂數命名</code>，降低碰撞。</p><ol><li>透過子網域的方式</li><li>透過亂數命名 hostname，但是用 attribute 標記 部門、組織、專案屬性</li></ol><h2 id="Q-數量太龐大，難以使用"><a href="#Q-數量太龐大，難以使用" class="headerlink" title="Q: 數量太龐大，難以使用"></a>Q: 數量太龐大，難以使用</h2><p>資源的數量太多，造成 Id 長度很大，使用時需要提供完整 Id 資訊，才能確認。對於人而言，這是個苦差事。</p><p>幾種解法：</p><ul><li><code>QR Code</code>：透過圖形化的方式，轉化超長的 Id</li><li><code>Bar Code</code>：概念同 QR Code，經常用在水費、電費帳單</li><li><code>縮小範圍</code>：常見的例子是電商購物取貨，透過兩階段範圍限縮，達到精準取貨：<ol><li>限縮範圍：<code>超商</code> 本身就是個小範圍的籃子 (Bucket)，</li><li>索引反轉：原本訂單編號是難以理解的，反轉成使用者自身的資訊，像是身分證末三碼、手機末三碼，重新對應到訂單編號</li></ol></li></ul><hr><h1 id="常見的實作"><a href="#常見的實作" class="headerlink" title="常見的實作"></a>常見的實作</h1><p>幾個常見的 ID 實作 (以下部分由 ChatGPT 產生)：</p><h2 id="UUID-Universally-Unique-Identifier"><a href="#UUID-Universally-Unique-Identifier" class="headerlink" title="UUID (Universally Unique Identifier)"></a>UUID (Universally Unique Identifier)</h2><p>設計考量： UUID 是由標準定義的一組算法來生成的，其中包括基於時間、隨機數或其他唯一性來確保生成的 ID 全球唯一。常見的版本包括 UUIDv1（基於時間戳）、UUIDv4（隨機生成）等。</p><p>適合的場景： UUID 非常適合需要全局唯一性的場景，例如分佈式系統中的唯一標識符，以及需要在不同系統之間進行數據交換的情況下。</p><p>針對資料庫設計的 <a href="https://vladmihalcea.com/uuid-database-primary-key/">TSID (Time-Sorted Unique Identitifer)</a></p><h2 id="雪花演算法-Snowflake-ID"><a href="#雪花演算法-Snowflake-ID" class="headerlink" title="雪花演算法 (Snowflake ID)"></a>雪花演算法 (Snowflake ID)</h2><p>設計考量： <a href="https://duckduckgo.com/?q=Snowflake+ID&atb=v255-4__&ia=web">Snowflake ID</a> 是 Twitter 提出的一種分布式 ID 生成算法，它結合了時間、機器 ID 和序列號來生成全局唯一的 ID。時間戳確保 ID 是有序的，機器 ID 確保唯一性，序列號則確保在同一時間內生成多個 ID 時的唯一性。</p><p>適合的場景： Snowflake ID 適用於需要大量且分佈式生成的 ID，例如分佈式系統中的數據庫主鍵、消息隊列的消息 ID 等場景。</p><h2 id="Auto-Increment"><a href="#Auto-Increment" class="headerlink" title="Auto-Increment"></a>Auto-Increment</h2><p>設計考量： 自增 ID 是由資料庫管理系統（如 MySQL、PostgreSQL）自動生成的，每次插入一條新記錄時，ID 會自動加一。這樣的設計簡單且高效，但僅限於單機系統或資料庫範圍內的唯一性。</p><p>適合的場景： 自增 ID 適用於單機系統或者資料庫範圍內的唯一性要求不高的場景，例如小型網站的用戶 ID、文章 ID 等。</p><h2 id="KGS-Key-Generation-Service"><a href="#KGS-Key-Generation-Service" class="headerlink" title="KGS (Key Generation Service)"></a>KGS (Key Generation Service)</h2><p>設計考量： KGS 是一種由中央服務器生成的 ID，並使用了分佈式的生成機制，確保全局唯一性。它可以採用類似於 Snowflake 的方法，但由中央服務器統一管理 ID 的生成，以防止 ID 的重複和衝突。</p><p>適合的場景： KGS 適用於需要強大唯一性保證和集中管理的分佈式系統，例如大型企業應用系統中的全局唯一標識符、金融交易系統中的訂單 ID 等。</p><hr><h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p>Id 設計背後要思考用途、未來性、實作的選擇，上述還有很多沒有整理：</p><ul><li><code>驗證</code>：如何驗證這個唯一性是否有被篡改過，也是設計要考慮的</li><li><code>外部操作與內部操作</code>：外部指的是 User Interface 的 Id，內部指的系統內部操作。前者是會揭露給使用者，使用者會拿來操作與溝通，後者則是系統內部自己在用的。</li></ul><p>這些之後有空再來整理。</p><hr><p>題外話: 你是 ID 還是 Id?</p><hr><h1 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h1><h2 id="站內資料"><a href="#站內資料" class="headerlink" title="站內資料"></a>站內資料</h2><ul><li><a href="/2017/07/07/AWS/Plan-And-Deisgn-Multiple-VPCs-in-Different-Regions/">Plan and Design Multiple VPCs in Different Regions</a></li><li><a href="/2020/03/07/ComputerScience/Cryptography/">摘要密碼學與資訊安全</a></li></ul><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul><li><a href="https://en.wikipedia.org/wiki/Unicode">Unicode</a></li><li><a href="https://www.hava.io/blog/cattle-vs-pets-devops-explained">Cattle vs Pets | DevOps Explained</a></li><li><a href="https://magiclen.org/tw-id-num/">如何寫程式處理中華民國的身份證字號？</a></li><li><a href="https://vladmihalcea.com/uuid-database-primary-key/">TSID – Time-Sorted Unique Identifiers</a></li><li><a href="https://repost.aws/questions/QUo8PH97hlS0KwUx5tNIc4JQ/instance-id-uniqueness">Instance ID uniqueness</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;整理一些設計 Identifier 要考慮的事情，特別是要揭露給使用者的時候，像是 RESTful API 的設計。原文來自 &lt;a href=&quot;https://www.facebook.com/rick.kyhwang/posts/pfbid02Kjy4HJRmN5HT2vtyno5p5pGHbbLdNYQR1QTRStqK4tj9CveE3TbxhnNiVtJ9YyCrl&quot;&gt;facebook&lt;/a&gt; 寫的草稿。&lt;/p&gt;</summary>
    
    
    
    <category term="System Design" scheme="https://rickhw.github.io/categories/System-Design/"/>
    
    
    <category term="API First" scheme="https://rickhw.github.io/tags/API-First/"/>
    
    <category term="API" scheme="https://rickhw.github.io/tags/API/"/>
    
    <category term="API Design" scheme="https://rickhw.github.io/tags/API-Design/"/>
    
    <category term="Identity" scheme="https://rickhw.github.io/tags/Identity/"/>
    
    <category term="Identifier" scheme="https://rickhw.github.io/tags/Identifier/"/>
    
    <category term="Unique" scheme="https://rickhw.github.io/tags/Unique/"/>
    
    <category term="UUID" scheme="https://rickhw.github.io/tags/UUID/"/>
    
  </entry>
  
  <entry>
    <title>資料備份還原 - 第二原則 重要性與存取頻率</title>
    <link href="https://rickhw.github.io/2024/03/17/Data/Data-Backup-And-Recovery-Principles-2-Critical/"/>
    <id>https://rickhw.github.io/2024/03/17/Data/Data-Backup-And-Recovery-Principles-2-Critical/</id>
    <published>2024-03-17T13:42:30.000Z</published>
    <updated>2025-06-27T12:21:44.337Z</updated>
    
    <content type="html"><![CDATA[<p>繼續整理資料備份原則，整理自 <a href="https://www.facebook.com/rick.kyhwang/posts/pfbid0YVKLRU8FJTARtasgLoKg2xt6u7pvM3BJ6oEEn4V5BDnscWdJsKdg3BtX3LwmeYHbl">Facebook</a> 寫的草稿。</p><p><a href="/2024/03/16/Data/Data-Backup-And-Recovery-Principles-1-DataTier/">上一篇</a> 整理了 <code>資料備份還原</code> 的 <code>第一原則</code>：<code>分層原則</code>，設計出發點是 <code>Durability</code>。接下來第二原則則是資料的 <code>重要性</code> 與 <code>存取頻率</code> 矩陣，如下圖：</p><p><img src="/images/Data/Principles-2-Data-Critical.png"></p><span id="more"></span><h2 id="重要性"><a href="#重要性" class="headerlink" title="重要性"></a>重要性</h2><p>重要性指的是：</p><blockquote><p>丟失後的後悔率有多高？可還原否？</p></blockquote><p>重要性分成  Critical &#x2F; Non-Critical 兩個指標。</p><p><code>Critical</code> 資料就像生活照片、錄影、創作、喜歡的懷舊影集 … 等。基本上掉了、遺失，就找不回來了、或很難找回來。</p><blockquote><p>重不重要就看你怎麼看待這些東西，你覺得他們是垃圾，那就是垃圾。</p></blockquote><p><code>NonCritical</code> 掉了也不會心痛，或者也容易找得回來。像是一些網路下載的程式安裝檔、電影、音樂 … 等。</p><h2 id="存取頻率"><a href="#存取頻率" class="headerlink" title="存取頻率"></a>存取頻率</h2><p>相對於重要性的另一個指標則是 <code>存取頻率 (Access Rate)</code> ，這只的都是備份資料的存取頻率，不能用放在行動裝置 (NB, Mobile … ) 的角度來看。</p><p>我用 <code>Cold Data</code> 和 <code>Warm Data</code> 這兩個維度，代表 <code>很少存取</code> 或是 <code>偶爾存取</code>。像很多照片，雖然很重要，但是其實不太常看，時間越久以前的，越不常存取，屬於 ColdData。有些資料會一直有固定更新，像是放在雲端硬碟的備份資料 (Google Drive &#x2F; DropBox)。</p><blockquote><p>其實還有 HotData，指的是 Tier1 的設備</p></blockquote><p>依照這兩個維度，可以展開一個矩陣 (如圖)，依照自己實際的資料去擺放與分類。</p><h2 id="怎麼驗證這個矩陣的有效性？"><a href="#怎麼驗證這個矩陣的有效性？" class="headerlink" title="怎麼驗證這個矩陣的有效性？"></a>怎麼驗證這個矩陣的有效性？</h2><p>第一種驗證方法，可以透過假設推論做驗證。</p><p>設計這個矩陣的背後的思路，就是當有天真的發生災難，電腦壞了、手機壞了、NAS 壞了、AWS S3 炸鍋了 … 第一時間，可以反映出 #資料損失程度，以及 #可還原比重。這個是整個背後設計的目的。</p><p>再來是當空間不夠的時候，如何有效的取捨？放在 NonCritical 的 ColdData 就是會直接被清掉，讓出空間。</p><blockquote><p>這裡有個邏輯矛盾，不重要的資料需要放 NAS？</p></blockquote><p>實際上，這整個原則都在討論資料備份原則，實際上我還沒真的談到 NAS 這個東西。但是會用 NAS，我個人的核心想法就是資料備份與還原，所以整個原則都是圍繞在資料存放原則上，而不是 NAS。</p><p>第二個應用是，平常如果想要調閱過往的資料，應該怎麼快速定位，例如：</p><ol><li>調閱 2008 年的資料，大概要怎麼找？</li><li>想找一張有 QNAP TS-469 Pro 的照片要怎麼找？ (現在可以透過其他方式，但成本太高)</li></ol><h2 id="備份的成本"><a href="#備份的成本" class="headerlink" title="備份的成本"></a>備份的成本</h2><p>備份本身還是有成本的，所以這個矩陣可以很輕易的選擇適當的解決方案存放資料，放在 NAS or S3？這樣的問題在這個矩陣可以輕易回答，圖二是我放在 S3 Glacier 的 ColdData，背後的邏輯與思路這樣設計的。</p><h2 id="分類的成本"><a href="#分類的成本" class="headerlink" title="分類的成本"></a>分類的成本</h2><p>這個矩陣很考驗使用者對於資料的認識，以及平常怎麼擺放資料。我自己平常就習慣會將資料做適度的歸檔以及分類，所以會有這樣的思路。這個矩陣基本上有點門檻，也會有些邏輯誤區。</p><p>背後設計的邏輯，搭配的是我從小到大的慣性思維 - <a href="/2014/10/26/Management/Classified-Philosophy/">分類</a>。</p><p>而實際應用 <code>第二原則</code> 會搭配 <a href="/2024/03/16/Data/Data-Backup-And-Recovery-Principles-1-DataTier/">第一原則 (Tier)</a> 一起使用，</p><hr><h1 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h1><h2 id="站內文章"><a href="#站內文章" class="headerlink" title="站內文章"></a>站內文章</h2><ul><li><a href="/2014/10/26/Management/Classified-Philosophy/">分類的哲學</a></li><li><a href="/2024/03/16/Data/Data-Backup-And-Recovery-Principles-1-DataTier/">第一原則</a>, <a href="https://www.facebook.com/rick.kyhwang/posts/pfbid02iwegHTWpBLGUsuvNn3GAoVp9iCiGTKvqTkD32FPCZKexgtMnVArbJ8PSDNUrG4Uil">草稿</a></li><li><a href="/2024/03/17/Data/Data-Backup-And-Recovery-Principles-2-Critical/">第二原則</a>, <a href="https://www.facebook.com/rick.kyhwang/posts/pfbid0YVKLRU8FJTARtasgLoKg2xt6u7pvM3BJ6oEEn4V5BDnscWdJsKdg3BtX3LwmeYHbl">草稿</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;繼續整理資料備份原則，整理自 &lt;a href=&quot;https://www.facebook.com/rick.kyhwang/posts/pfbid0YVKLRU8FJTARtasgLoKg2xt6u7pvM3BJ6oEEn4V5BDnscWdJsKdg3BtX3LwmeYHbl&quot;&gt;Facebook&lt;/a&gt; 寫的草稿。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/2024/03/16/Data/Data-Backup-And-Recovery-Principles-1-DataTier/&quot;&gt;上一篇&lt;/a&gt; 整理了 &lt;code&gt;資料備份還原&lt;/code&gt; 的 &lt;code&gt;第一原則&lt;/code&gt;：&lt;code&gt;分層原則&lt;/code&gt;，設計出發點是 &lt;code&gt;Durability&lt;/code&gt;。接下來第二原則則是資料的 &lt;code&gt;重要性&lt;/code&gt; 與 &lt;code&gt;存取頻率&lt;/code&gt; 矩陣，如下圖：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/Data/Principles-2-Data-Critical.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Data" scheme="https://rickhw.github.io/categories/Data/"/>
    
    
    <category term="Backup" scheme="https://rickhw.github.io/tags/Backup/"/>
    
    <category term="Recovery" scheme="https://rickhw.github.io/tags/Recovery/"/>
    
    <category term="NAS" scheme="https://rickhw.github.io/tags/NAS/"/>
    
    <category term="Durability" scheme="https://rickhw.github.io/tags/Durability/"/>
    
  </entry>
  
  <entry>
    <title>資料備份還原 - 第一原則 資料分層</title>
    <link href="https://rickhw.github.io/2024/03/16/Data/Data-Backup-And-Recovery-Principles-1-DataTier/"/>
    <id>https://rickhw.github.io/2024/03/16/Data/Data-Backup-And-Recovery-Principles-1-DataTier/</id>
    <published>2024-03-16T13:42:30.000Z</published>
    <updated>2025-06-27T12:21:44.337Z</updated>
    
    <content type="html"><![CDATA[<p>聊聊 NAS 的一些心得，整理 <a href="https://www.facebook.com/rick.kyhwang/posts/pfbid02iwegHTWpBLGUsuvNn3GAoVp9iCiGTKvqTkD32FPCZKexgtMnVArbJ8PSDNUrG4Uil">Facebook</a> 寫的草稿。</p><p>討論 NAS 這種「解決方案」之前，應該先好好想清楚，資料對於自己而言，到底有多重要？</p><p>NAS 對我來說核心價值就是 <code>備份資料</code> 與 <code>還原資料</code>，所以對於「資料」的存放，過去從早期用光碟備份資料，到後來使用 NAS，這麼多年的經驗累積下來之後，我設計了一些原則，定義備份與還原資料的原則，如下圖，<code>第一原則</code>：<code>資料分層原則</code> (如圖)</p><p><img src="/images/Data/Principles-1-Data-Tier.png"></p><span id="more"></span><hr><h2 id="第一原則：資料分層"><a href="#第一原則：資料分層" class="headerlink" title="第一原則：資料分層"></a>第一原則：資料分層</h2><h3 id="Tier-1-存放在使用設備的資料"><a href="#Tier-1-存放在使用設備的資料" class="headerlink" title="Tier#1: 存放在使用設備的資料"></a>Tier#1: 存放在使用設備的資料</h3><p>使用設備 包含 PC &#x2F; Laptop &#x2F; Mobile 等設備，像是 iMac, MacBook, iPhone … etc，這些設備都是日常使用頻率很高，但幾年就會汰換，或者可能因為硬體故障、意外故障 … 等。</p><p>這些資料通常也都是溫度較高的，存取率比較多。當然這是我個人的原則，我知道很多人不是這樣。</p><h3 id="Tier-2-存放-T-1-備份的實體設備"><a href="#Tier-2-存放-T-1-備份的實體設備" class="headerlink" title="Tier#2: 存放 T#1 備份的實體設備"></a>Tier#2: 存放 T#1 備份的實體設備</h3><p>通常是 T#1 的外接儲存設備，放在固定的位置，壽命略高於 T#1，但還是會故障、損毀。</p><p>外接儲存設備就是一個單一的外接硬碟，或者光碟，這也是早期最常備份資料的方法。通常會定期 (Monthly &#x2F; Weekly) 備份一次。 Mac 的 TimeMachine 也是這樣的概念。</p><p>進階一點的外接儲存設備就是 <code>NAS (Network Attached Storage)</code>，當資料數量到一定程度之後，才會採購的設備。</p><h3 id="Tier-2-5-備份-Tier-2"><a href="#Tier-2-5-備份-Tier-2" class="headerlink" title="Tier#2.5: 備份 Tier#2"></a>Tier#2.5: 備份 Tier#2</h3><p>這是 T#2 的同地方的複本，像是把 T#2 再做一次備份的概念，地理位置是放在同一個地方 (空間)，但是可以隨意帶到不同地理位置的方式。這個概念大概就是像另一顆硬碟，或者另一台 NAS or 容量足夠大的硬碟。</p><p>#T#1, #2 都會故障 &#x2F; 壞掉 &#x2F; 丟失，所以只有這兩個是不夠的。</p><h3 id="Tier-3-存放在非本地的複本"><a href="#Tier-3-存放在非本地的複本" class="headerlink" title="Tier#3: 存放在非本地的複本"></a>Tier#3: 存放在非本地的複本</h3><p>T#3 是 T#2 的距離延伸，只要地理位置不一樣就算了。</p><p>T#3 現在其實很多人在用，像是 Google Drive, DropBox, … 等 都算是。另外一種像是利用公有雲 AWS S3 &#x2F; GCP Storage … 等也都是。如果把 T#2.5 帶到不一樣的地理位置，其實也可以成立，像是資料的異地備份。</p><p>NAS 本質還是資料儲存，所以基本上都專注在，怎麼 #保存資料 以及 #怎麼還原 這兩件事情。所以如果沒有一個資料存放的原則，買什麼設備其實都一樣，最後只要災難發生，資料就不見了，那就沒意義了。</p><h2 id="設計原則：-Durability"><a href="#設計原則：-Durability" class="headerlink" title="設計原則： Durability"></a>設計原則： Durability</h2><p>Tier 背後設計的概念是 <code>Durability</code>，就是從時間上來看，資料可用以及正確的持久性。</p><p>做系統設計的人，可能會聯想到這張圖 (出自 <a href="https://www.youtube.com/watch?v=-D4v2uK3YCw&t=1847s">AWS Summit Series 2016 - Big Data Architectural Patterns and Best Practices on AWS</a>)，這其實是我背後的底層邏輯：</p><p><img src="/images/AWS/Data-Characteristics_on-AWS.png"></p><p>下一篇，整理 <a href="/2024/03/17/Data/Data-Backup-And-Recovery-Principles-2-Critical/">第二原則</a>。</p><hr><h1 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h1><h2 id="站內文章"><a href="#站內文章" class="headerlink" title="站內文章"></a>站內文章</h2><ul><li><a href="/2016/08/17/AWS/Study-Notes-DynamoDB/">Study Notes - DynamoDB 學習筆記</a></li><li><a href="/2024/03/16/Data/Data-Backup-And-Recovery-Principles-1-DataTier/">第一原則</a>, <a href="https://www.facebook.com/rick.kyhwang/posts/pfbid02iwegHTWpBLGUsuvNn3GAoVp9iCiGTKvqTkD32FPCZKexgtMnVArbJ8PSDNUrG4Uil">草稿</a></li><li><a href="/2024/03/17/Data/Data-Backup-And-Recovery-Principles-2-Critical/">第二原則</a>, <a href="https://www.facebook.com/rick.kyhwang/posts/pfbid0YVKLRU8FJTARtasgLoKg2xt6u7pvM3BJ6oEEn4V5BDnscWdJsKdg3BtX3LwmeYHbl">草稿</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;聊聊 NAS 的一些心得，整理 &lt;a href=&quot;https://www.facebook.com/rick.kyhwang/posts/pfbid02iwegHTWpBLGUsuvNn3GAoVp9iCiGTKvqTkD32FPCZKexgtMnVArbJ8PSDNUrG4Uil&quot;&gt;Facebook&lt;/a&gt; 寫的草稿。&lt;/p&gt;
&lt;p&gt;討論 NAS 這種「解決方案」之前，應該先好好想清楚，資料對於自己而言，到底有多重要？&lt;/p&gt;
&lt;p&gt;NAS 對我來說核心價值就是 &lt;code&gt;備份資料&lt;/code&gt; 與 &lt;code&gt;還原資料&lt;/code&gt;，所以對於「資料」的存放，過去從早期用光碟備份資料，到後來使用 NAS，這麼多年的經驗累積下來之後，我設計了一些原則，定義備份與還原資料的原則，如下圖，&lt;code&gt;第一原則&lt;/code&gt;：&lt;code&gt;資料分層原則&lt;/code&gt; (如圖)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/Data/Principles-1-Data-Tier.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Data" scheme="https://rickhw.github.io/categories/Data/"/>
    
    
    <category term="Backup" scheme="https://rickhw.github.io/tags/Backup/"/>
    
    <category term="Recovery" scheme="https://rickhw.github.io/tags/Recovery/"/>
    
    <category term="NAS" scheme="https://rickhw.github.io/tags/NAS/"/>
    
    <category term="Durability" scheme="https://rickhw.github.io/tags/Durability/"/>
    
  </entry>
  
  <entry>
    <title>SaaS 關鍵設計 - Multi-Tenancy - 探討真實世界的租賃關係</title>
    <link href="https://rickhw.github.io/2023/09/11/DistributedSystems/SaaS-KeyDesign_MultiTenancy-with-Isolation-Factor/"/>
    <id>https://rickhw.github.io/2023/09/11/DistributedSystems/SaaS-KeyDesign_MultiTenancy-with-Isolation-Factor/</id>
    <published>2023-09-11T14:30:00.000Z</published>
    <updated>2025-08-03T00:11:30.215Z</updated>
    
    <content type="html"><![CDATA[<p><code>多租戶架構 (Mulit-Tenancy Architecture, 以下稱作 MTA)</code> 是 <code>SaaS (Software as a Service, 軟體及服務)</code> 設計的核心議題，也是我過去幾年工作研究的題目之一，大部分的人針對這個題目討論的多是 K8s 的 Namespace 劃分、或者資料庫的拆分方式、使用 Single or Shared &#x2F; Hybrid … 等策略。</p><p>多租戶架構背後需要討論的，除了這些技術架構的議題，更重要的是往前一步：</p><blockquote><p>SaaS 的 <code>多租戶</code> 應該怎麼定義？以及能夠解決那些問題？</p></blockquote><p>基於這些討論與實踐，最後我提出設計 MTA 的關鍵抽象概念，我把它稱為 <code>Isolation Factor (隔離因子)</code>。</p><p>這篇文章嘗試解釋與探討 <code>多租戶</code> 背景與核心議題，同時用真實世界的租賃關係，剖析設計 SaaS 時必須要知道的概念，嘗試帶出 Isolation Factor 的重要性。</p><blockquote><p>相關文章：</p><ul><li><a href="/2022/07/04/DistributedSystems/Inspired-Design-From-Eclipse/">摘要 Eclipse 設計的啟發：當代 SaaS 分散式架構的關鍵設計</a></li><li><a href="/2023/06/24/DistributedSystems/API-First_Communication-Protocol/">API 設計 - 摘要 API 通訊模式與協議</a></li><li><a href="/2021/05/14/DistributedSystems/Service-Governance/">聊聊分散式架構的服務治理</a></li></ul></blockquote><span id="more"></span><hr><h1 id="真實世界裡的租賃關係"><a href="#真實世界裡的租賃關係" class="headerlink" title="真實世界裡的租賃關係"></a>真實世界裡的租賃關係</h1><p>在真實的世界中，有幾種角色關係：</p><ul><li><code>房東 (Landlord)</code>：出租房子的人成為房東<ul><li>英文用詞：Landlord, Landlady</li><li>物件在法律上的資產擁有者，具備 <code>擁有權</code></li><li>對於物件有 <code>管理權</code> 以及 <code>使用權</code></li><li>承租合約成立區間，不具備使用權</li></ul></li><li><code>房客 (Lodger)</code>：指的是房子的承租者 (人) - 中文叫做 <code>租戶</code>、<code>房客</code>、<code>承租人</code>、或 <code>佃戶</code><ul><li>英文用詞：Lodger、Tenant</li><li>承租對象的是房東提供的 <code>承租物件</code></li><li>在雙方約定的時間範圍之內，房客 <code>具備</code> 承租物件的 <code>使用權</code></li><li>約定時間之內，非特定情境，房東 <code>不具備</code> 承租物件的使用權</li></ul></li><li><code>承租物件 (Object)</code> ：與租戶對應的房子稱為 <code>承租物件 (Object)</code>、出租處<ul><li>英文用詞：老美稱為 apartment、英國稱為 flat。</li><li>承租物件內部使用稱為使用權，物件以外稱為管理權</li><li>物件以外，在真實世界稱為公共空間、公共設施、公共區域 … etc.</li></ul></li><li><code>合約 (Rental Agreements)</code>：指房東 &#x2F; 租戶 雙方對於 承租物件 的使用權 承諾<ul><li>合約包含以下資訊：<ol><li><code>房客 (who)</code> 識別資訊，通常是個人身份、職業，目的是用來識別法律上的效益。</li><li>允許使用的 <code>時間範圍 (when)</code></li><li>對於承租物件的 <code>權利與義務 (what)</code></li><li>更多參閱 <a href="https://en.wikipedia.org/wiki/Rental_agreement">Rental agreement</a></li></ol></li><li>用詞：tenancy (租賃)，通常用在房屋、土地等不動產的</li></ul></li><li><code>承租 (Lease, v)</code>：租戶向房東簽訂使用合約，整個動作稱為 <code>承租</code></li><li><code>使用權</code>: 泛指承租者 (房客) 在合約期限內，對於承租物件的使用範圍，其中包含承租物件本身以及公共區域的使用權</li><li><code>管理權</code>: 承租物件內部與外部的管制與控制</li><li><code>擁有權 (Ownership)</code>: 泛指資產在法律上賦予的擁有權</li></ul><p>這些關係稱為 <code>租賃 (Tenancy)</code>，概念如下圖所示：</p><p><img src="/images/DistributedSystems/MultiTenancy/lodger-landlord-rental-agreement_v20230911.png"></p><p>了解基本租賃的幾個角色、關係之後，我想把主軸放在 <code>房東</code>、<code>承租物件</code>、<code>房客</code> 這三者的關係，然後套到的 SaaS 設計裡。</p><blockquote><p>註：雖然房客 (Lodger) 的英文也可以是 Tenant 這個字，但是實際上中文口語上描述 <code>租戶</code> 的時候，可以意指 <code>人 (房客)</code>、或者是 <code>承租物件 (Object)</code>，通常要看前後文判斷，本文會直接使用 Object 直接代表承租房子，避免語意錯置。</p></blockquote><h2 id="其他專有名詞"><a href="#其他專有名詞" class="headerlink" title="其他專有名詞"></a>其他專有名詞</h2><ul><li>垂直權限</li><li>水平權限</li><li>仿登入 (impersonate), 概念類似 sudo &#x2F; run as xxx</li><li>RBAC (Role-Based Access Control)</li><li>ABAC (Role-Based Access Control)</li></ul><hr><h1 id="背景探討：各種租賃組合"><a href="#背景探討：各種租賃組合" class="headerlink" title="背景探討：各種租賃組合"></a>背景探討：各種租賃組合</h1><h2 id="租賃關係的排列組合"><a href="#租賃關係的排列組合" class="headerlink" title="租賃關係的排列組合"></a>租賃關係的排列組合</h2><p><code>Multi-Tenancy</code> 這個字，中文翻譯成：<code>多租戶</code>，字面上看似容易理解，但在設計與實作時，卻很容易做出有問題的設計。接下用 <code>房東 (Landlord)</code>、<code>承租物件 (Object)</code>、以及 <code>房客 (Lodger)</code>，三者的數量關係，分別探討各種形式的租賃關係。</p><p>三個變動因子，每個變動因子都有 <code>一個</code> 或 <code>多個</code> 兩種選項，其排列組合列舉如下表：</p><p><img src="/images/DistributedSystems/MultiTenancy/Rental-Agreements-Matrix_v20230911.png"></p><p>探討過程，我會嘗試用真實世界的案例帶入，如果沒有舉例的，可能是我自己經歷不夠、想像力不足，或者是 … 排列組合根本就不合理。</p><p>首先先從 <code>多租戶</code> 這個詞的相對詞：<code>單一租戶 Single Tenant</code> 切入。</p><h2 id="Case-A-Single-Tenant"><a href="#Case-A-Single-Tenant" class="headerlink" title="Case A: Single Tenant"></a>Case A: Single Tenant</h2><p><code>Single Tenant</code> 指的是 <code>一個房東</code> 可以提供 <code>一個物件</code> 給 <code>一個房客</code> 承租 ，完成 <code>一個租賃合約</code>，這三者的關係如下圖：</p><p><img src="/images/DistributedSystems/MultiTenancy/CaseA_Single-Tenant_v20230911.png"></p><p>這三者是一對一對一的關係：</p><blockquote><p>房東：承租物件：房客 &#x3D; 1：1：1</p></blockquote><p>生活中常見的例子，像是一個大樓的 (一個) 房東，將一整棟大樓租賃給一家企業。</p><ul><li>一個房東</li><li>一棟大樓</li><li>一家企業</li></ul><h2 id="Case-B-Multiple-Tenant"><a href="#Case-B-Multiple-Tenant" class="headerlink" title="Case B: Multiple Tenant"></a>Case B: Multiple Tenant</h2><p>房東只有一個物件可以承租給房客？雖然有，但是不是普通鄉民會接觸的。</p><p>生活中更多的例子會是一個房東同時擁有多個物件可以出租，也就是 <code>一個房東</code> 可以提供 <code>多個物件</code> 給 <code>多個房客</code> 承租 ，完成 <code>多個租賃合約</code>，這三者的關係如下圖：</p><p><img src="/images/DistributedSystems/MultiTenancy/CaseB_Multiple-Tenant_v20230911.png"></p><p>這三者的關係是：</p><blockquote><p>房東：承租物件：房客 &#x3D; 1：N：N</p></blockquote><p>注意，這裡描述 <code>承租物件</code> 與 <code>房客</code> 兩者是一對一關係，也就是每一個物件，只承租給一個客戶。不是一個物件，承租給多個客戶，這種結構在最後會描述。</p><p>在真實世界的租賃中，承租物件已經具備明確的 <code>邊界 (Border)</code>，像是房屋都具備具象化的牆壁、隔間、房門等邊界，所以房內屬於私人區域、以外則公共區域，公私領域的邊界是清楚，且明確的。</p><p>而所謂的 <code>多租戶</code> 這個詞背後隱含的是：</p><blockquote><p>相對於房東而言，也就是我們都是站在房東角度在論述。</p></blockquote><p>這句話很重要，請留意思考的切入角度 (角色)，本文全文的論述其實都是房東角度。</p><h2 id="Case-C"><a href="#Case-C" class="headerlink" title="Case C"></a>Case C</h2><p>上述 <code>Case A: Single Tenant</code> 和 <code>Case B: Multiple Tenant</code> 是真實世界常見的例子，屬於正常、合理的例子。</p><p>接下來我們來探討第三個例子，其結構如下圖：</p><p><img src="/images/DistributedSystems/MultiTenancy/CaseC_Single-Landlord-Lodger_Mulitple-Objects_v20230911.png"></p><p>這三者關係是：</p><blockquote><p>房東：承租物件：房客 &#x3D; 1：N：1</p></blockquote><p>這個意思是，一個房東，擁有 N 個物件，但是都租給同一個房客，會有這樣的案例？現實生活中，也許有吧？不曉得 … 貧窮限制我的想像啊。。。。</p><h2 id="Case-D"><a href="#Case-D" class="headerlink" title="Case D"></a>Case D</h2><p>排列組合還有，繼續推演下一個狀況：</p><p><img src="/images/DistributedSystems/MultiTenancy/CaseD_Single-Landlord-Object_Multiple-Lodger_v20230911.png"></p><p>這三者關係是：</p><blockquote><p>房東：承租物件：房客 &#x3D; 1：1：N</p></blockquote><p>這個狀況的意思是：</p><blockquote><p>一個房東的其中一個物件，同時租給多個房客，背後有多個契約。</p></blockquote><p>真實案例像是青年旅館，一個大通鋪，一堆人住一個晚上。在 IT 系統裡，有點像是一家公司申請一個 AWS Account，在裡面部署一套系統，這套系統，同時租賃給多個客戶使用。</p><hr><h1 id="探討"><a href="#探討" class="headerlink" title="探討"></a>探討</h1><p>上一段整理了四個排列組合，真實世界的運作往往會比這些單一排列組合更複雜，更多的是複合式的組合。</p><p>我們就用這四個為基礎單位，探討真實世界的組合。</p><h2 id="探討一：Case-X1-x3D-Case-B-D"><a href="#探討一：Case-X1-x3D-Case-B-D" class="headerlink" title="探討一：Case X1 &#x3D; Case B + D"></a>探討一：Case X1 &#x3D; Case B + D</h2><p>上述 Case B &#x2F; D 有著很類似的概念，不過看到這裡的讀者可能腦袋也打結了 XD</p><p>重新整理這兩者的關係如下：</p><p>Case B:</p><blockquote><p>房東：承租物件：房客 &#x3D; 1：N：N</p></blockquote><p>Case D</p><blockquote><p>房東：承租物件：房客 &#x3D; 1：1：N</p></blockquote><p>把這兩個 Case 合併成 <code>Case X1</code> 如下圖：</p><p><img src="/images/DistributedSystems/MultiTenancy/CaseX1_B+D_v20230911.png"></p><p>用 AWS 的角度舉例說明，圖中的角色分別如下：</p><ul><li>Landlard: AWS</li><li>Object: AWS Account</li><li>Lodgers: AWS IAM 裡的 User</li></ul><p>這個例子，如果用過 AWS 的人應該不難理解，不過要留意的是，每個 AWS Account 裡的資源彼此是看不到彼此的，像是:</p><ul><li><code>User#A @ Object#A</code> 是無法直接跟 <code>User#A @ Object#B</code> 對話的</li><li><code>Object#B</code> 是無法得知 <code>Object#A</code> 裡有哪些 Users</li><li><code>User#A @ Object#A</code> 不等於 <code>User#A @ Object#B</code></li></ul><p>上面的描述，背後隱含的關鍵意義就是 Object 之間是 <code>隔離</code> 的，而且是強制性的隔離。</p><p>換 GCP 的例子：</p><ul><li>Landlard: GCP</li><li>Object: GCP Project</li><li>Lodgers: GCP Project IAM User</li></ul><p>這個也不難理解，同樣可以舉例出 Object 之間隔離的概念，也完全與 AWS 一致。</p><p>GCP 與 AWS 的隔離概念稱為 <code>垂直權限 (Vertical Authority)</code></p><p>繼續下一個例子是 K8s:</p><ul><li>Landlard: K8s Cluster</li><li>Object: by Namespace</li><li>Lodgers: Application or Developer</li></ul><p>K8s 開始出現一個狀況，所謂的 Namespace 只是邏輯概念切割，也就是資源之間的並不是 <code>強隔離</code>。</p><h2 id="探討二：二房東-Case-X2"><a href="#探討二：二房東-Case-X2" class="headerlink" title="探討二：二房東 Case X2"></a>探討二：二房東 Case X2</h2><p>上述 Case E 用 AWS &#x2F; GCP &#x2F; K8s 當例子，但更多時候企業在發展自己的業務狀況會是這樣：</p><p><img src="/images/DistributedSystems/MultiTenancy/CaseX2_B+B_v20230911.png"></p><p>把 <code>Object#A</code> 拆分，自己變成二房東，租一個物件，但是這個物件拆分成 N 個，每個再租給其他的使用者。</p><p>而如何把 Object#A 拆分的好與壞，就在於隔離的實作。</p><p>前面提到在真實世界的租賃中，承租物件已經具備明確的 <code>邊界 (Border)</code>，但是承租 AWS 的企業，又把這個 SaaS 承租給他們的客戶，而對於 SaaS 客戶而言，邊界應該、必須要存在，而這個邊界則需要由 SaaS 公司在架構設計時，必須自己建立一道讓客戶以為的邊界，這個邊界，在本文中稱為 <code>隔離 (Isolation)</code>。</p><h2 id="隔離的核心議題-Isolation-Factor-隔離因子"><a href="#隔離的核心議題-Isolation-Factor-隔離因子" class="headerlink" title="隔離的核心議題: Isolation Factor (隔離因子)"></a>隔離的核心議題: Isolation Factor (隔離因子)</h2><p>本質上來講，隔離是透過一種 <code>邊界 (Boundary)</code> 方式，區分租戶彼此之間的空間範圍。</p><p>房子來講，區分彼此的空間範圍就是樑柱、牆壁、門、地板、天花板 … 等；以企業內部來講，就是各種辦公室的實體隔間、以及特定角色授權；以應用程式來說，就是使用者 A 能否看到使用 B 的資料而言。依照這樣的隔離概念，底下這些都是犯規：</p><ul><li>企業大樓裡，未經授權的員工，進入機房</li><li>企業員工在 AWS 上開台機器，沒有認證授權，方便自己進出公司網域</li><li>SRE 說：我的 Gmail 看到別人的信，就要把 Gmail shutdown! –&gt; <a href="https://www.ithome.com.tw/news/105366">相關報導</a></li><li>薩爾達傳說 - 王國之淚: 看我通天術 (這嚴重犯規 XDD)<br><img src="/images/DistributedSystems/MultiTenancy/zelda-totk.jpeg"></li></ul><h3 id="實體隔離與邏輯隔離"><a href="#實體隔離與邏輯隔離" class="headerlink" title="實體隔離與邏輯隔離"></a>實體隔離與邏輯隔離</h3><p>在商業應用程式裡，隔離則因為 <code>領域 (Domains)</code> 不同，會用不同的方式，商業應用角度多半會以 <code>邏輯隔離</code> 為主。</p><p>邏輯隔離的例子，舉例常見的概念：</p><ul><li>Google 服務 (Gmail &#x2F; Gmap &#x2F; Docs …) 都是以 Gmail Account 為隔離單位</li><li>GCP 以 Project 為隔離單位</li><li>AWS 則以 Account 為單位</li><li>Chrome 這個瀏覽器則以 Profile 為隔離概念</li><li>多租戶架構的電商平台，隔離則是以 <code>店</code> 為單位，像是 91APP 是開店平台</li><li>教育平台，則是以學校為單位，像是 <a href="https://teachable.com/">Teachable</a> 這個平台<ul><li>開學校之後，每個學校都可以有自己的學生、自己的老師 .. 等角色定義</li></ul></li><li>作業系統的隔離：Linux 的系統權限 user-group-anyone 本質上就是種隔離</li><li>資料庫的隔離：Database &#x2F; Table &#x2F; Row 都是隔離概念，更甚者則是交易過程的鎖。</li></ul><p>上述的隔離，在權限系統稱為 <code>垂直權限</code>，也就是透過 <code>帳號 (通常)</code> 隔離彼此。除了垂直權限，相對則是 <code>水平權限</code>，概念如下圖：</p><p><img src="/images/DistributedSystems/MultiTenancy/SaaS-Multi-Tenancy-Permission-Design_v20230911.png"></p><p>但是當業務發展到一定程度之後，或者依照法規的需求，則很常會以期望實體隔離，也就是在實體的系統架構，就是 <code>專用 (Dedicated)</code> 資源，不與其他人共用。<br>不管是實體還是邏輯隔離，都需要一個關鍵因子來定義怎麼隔離？而這個隔離的關鍵因子我把它稱為 <code>隔離因子 (Isolation Factor)</code></p><p>前面描述的手段與方法都是為了達到隔離：</p><ul><li>權限：多租戶架構常用的方法是 <code>垂直權限</code><ul><li>相對於垂直權限，稱為 <code>水平權限</code>，實踐方式有 RBAC、ABAC</li></ul></li><li>實體隔離 (physical isolation)</li><li>邏輯隔離 (logical isolation): 虛擬化 virtualization, VPC</li></ul><h3 id="AWS-服務的隔離因子"><a href="#AWS-服務的隔離因子" class="headerlink" title="AWS 服務的隔離因子"></a>AWS 服務的隔離因子</h3><p>AWS 有很多服務，舉凡 EC2 &#x2F; S3 &#x2F; DynamoDB &#x2F; CloudFront … etc. 這些服務在 AWS 裏面都需要計算隔離方式，但是每個服務本身的屬性不一樣，在設計的時候怎麼知道每個服務的隔離因子是什麼？底下列舉設計 AWS 服務要考慮的隔離因子：</p><ul><li>EC2: Instance</li><li>S3: Bucket</li><li>DynamoDB: Table</li><li>CloudFront: Distribution</li><li>VPC 本身就是個隔離單位</li></ul><p>上述列舉的是這些服務的隔離因子例子，因為每個服務特性有所差異，要對應到 AWS Account 時，就要具體用一個單位對應隔離的想法，不然就會無法對應。</p><h2 id="隔離沒做好會怎樣？"><a href="#隔離沒做好會怎樣？" class="headerlink" title="隔離沒做好會怎樣？"></a>隔離沒做好會怎樣？</h2><p>這是隔離背後要解決的關鍵痛點，最經典的案例是下圖：</p><p><img src="/images/DistributedSystems/MultiTenancy/20160421_SRE.png"><br>Source: <a href="https://www.ithome.com.tw/news/105366">Google儲存SRE團隊負責人第一手經驗大公開</a>, by ITHome, 20160421</p><p>另一個經典案例則是 VPC 的問題，底下截圖則是中國知名技術專家 <a href="https://coolshell.me/">陳皓</a> 的部落格：</p><p><img src="/images/DistributedSystems/MultiTenancy/20200419_AliyunVPC.png"><br>Source: <a href="https://www.ithome.com.tw/news/105366">关于阿里云经典网络的问题</a>, by Coolshell, 20200419</p><p>這都是別人的問題，而我面對過的問題則是之前在電商工作時，曾經出現的問題，我把它稱為 <code>A-c-B event</code>，中文稱為 <code>A 店跨 B 店</code>。也就是 B 店的使用者，看到 A 店的資料，不管是商品資料、還是訂單資料。</p><p>這三個例子，資安角度都是 <code>垂直權限</code> 的問題，背後實際問題就是隔離的設計與實踐。</p><blockquote><p>案例更新：</p><ul><li>2023&#x2F;09&#x2F;29: <a href="https://www.ithome.com.tw/news/159045">Google Bard臭蟲讓用戶對話出現在公開Google搜尋結果中</a> 也屬於隔離沒做好造成的。</li><li>2025&#x2F;08&#x2F;03: <a href="https://money.udn.com/money/story/5599/8913932">ChatGPT 驚爆對話外洩 內線交易、不雅照內容全被看光光 OpenAI 急救火</a></li></ul></blockquote><h2 id="跨租戶問題常見的做法"><a href="#跨租戶問題常見的做法" class="headerlink" title="跨租戶問題常見的做法"></a>跨租戶問題常見的做法</h2><p>雖然說跨租戶是不允許的，但是生活中還是有很多場景，需要跨租戶存取，例如我們信用卡掛失的時候，客服人員可以幫你調整信用卡的狀態。客服人員代替你調整信用卡的過程，就是個跨租戶操作，不管怎樣他要操作設定的時候，都要獲得你的允許，然後才能幫你調整狀態。這樣的過程，其實就是個身份暫時轉換，代理 (delegate) 執行的過程。</p><p>類似的做法，在作業系統已經都有很成熟的做法：</p><ul><li>Linux: sudo as XXX</li><li>Windows: Run as XXXX</li></ul><p>在系統實作時，專有名詞為 <code>impersonate (v)</code>，也就是 <code>User#A@Tanent#A as User#B@Tenant#B</code>，這是個需要授權程序的。</p><p>在 AWS 的設計，幾種常見的例子：</p><ul><li>當 Account#A 要存取 Account#B 得時候，可以透過 STS 取得臨時授權</li><li>當網路要相互連線時，需要透過雙方授權才能連結，像是 VPC Peering</li></ul><!--多租戶重點？在單一使用者個人電腦作業系統，Kernel Space / User Space 可以類似於這樣的概念。- Isolation for What?- Multi-tenant Application (MTA)- Multi-instance Solution (MIS)## Isolation 的層次- Application Resource (VM)- Data Isolation    - Database    - Storage    - Shared Isolation:    - ref        - https://oncodedesign.com/data-isolation-and-sharing-in-multitenant-system-part1/        - https://oncodedesign.com/data-isolation-and-sharing-in-multitenant-system-part2/        - https://oncodedesign.com/data-isolation-and-sharing-in-multitenant-system-part3/## 常見的問題底下問題是跟不同人討論過程，發現對於 Multi-tenancy 的理解上，常見的提問。### Q: Tenant#A 裡的 User#A 跟 Tenant#B 裡的 User#A 是否同一個人？--><hr><h1 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h1><p>下圖是一張網路梗圖：</p><p><img src="/images/DistributedSystems/MultiTenancy/Multiple-Windows.jpg"><br>Source: <a href="https://www.facebook.com/groups/it.humor.and.memes/posts/24452121121053675/">https://www.facebook.com/groups/it.humor.and.memes/posts/24452121121053675/</a></p><p>圖中在 Windows 裡裝了 VMWare，然後裡面裝了 Windows，裡面再裝 VMWare … 如此好幾層 … 這張圖表述了多租戶的核心概念，不過大家知道 VM 本身是模擬硬體，換言之實作的是實體隔離。相對於 VM 則是 Container，透過 Kernal 的特性 (cgroup, namespace … etc)，時做出隔離的概念。</p><p>而應用程式如果要做出隔離概念，則必定要面對如何定義租戶的概念，租戶本質就是為了達到隔離，用來隔離的 <code>隔離因子 (Isolation Factor)</code>，則是本文想帶出的概念。</p><p>多租戶架構因而衍生的相關議題：</p><ol><li>水平權限系統，像是 RBAC &#x2F; ABAC，也就是 AWS IAM<ul><li>衍生的則是 API 認證授權與通訊協議，相關參閱 <a href="/2023/06/24/DistributedSystems/API-First_Communication-Protocol/">API 設計 - 摘要 API 通訊模式與協議</a></li></ul></li><li>租戶與 <code>功能</code> 的訂閱市集 (Marketplace)，背後本質是個 Pub&#x2F;Sub 概念<ul><li>相關參閱 <a href="/2022/07/04/DistributedSystems/Inspired-Design-From-Eclipse/">摘要 Eclipse 設計的啟發：當代 SaaS 分散式架構的關鍵設計</a></li></ul></li><li>帳務系統：延續租戶與功能訂閱而產生的議題，也就是使用狀況 (Usage) 與帳務資訊 (Billing)</li><li>功能系統的通訊架構，相關參閱 <a href="/2022/07/04/DistributedSystems/Inspired-Design-From-Eclipse/">摘要 Eclipse 設計的啟發：當代 SaaS 分散式架構的關鍵設計</a></li></ol><!--source: https://docs.google.com/presentation/d/1tPPkhBHIdGeWC7He4782rzwIr7SFr8VCBNrT50Wjwng/edit#slide=id.p--><hr><h1 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h1><h2 id="站內文章"><a href="#站內文章" class="headerlink" title="站內文章"></a>站內文章</h2><ul><li><a href="/2022/07/04/DistributedSystems/Inspired-Design-From-Eclipse/">摘要 Eclipse 設計的啟發：當代 SaaS 分散式架構的關鍵設計</a></li><li><a href="/2023/06/24/DistributedSystems/API-First_Communication-Protocol/">API 設計 - 摘要 API 通訊模式與協議</a></li><li><a href="/2021/05/14/DistributedSystems/Service-Governance/">聊聊分散式架構的服務治理</a></li></ul><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul><li><a href="http://en.wikipedia.org/wiki/Multitenancy">Multitenancy</a></li><li><a href="https://blog.arkency.com/comparison-of-approaches-to-multitenancy-in-rails-apps/">Comparison of approaches to multitenancy in Rails apps</a></li><li><a href="https://cloud.google.com/kubernetes-engine/docs/best-practices/enterprise-multitenancy">Best practices for enterprise multi-tenancy</a> - GKE</li><li>General Design Concepts<ul><li><a href="https://learn.microsoft.com/en-us/azure/azure-sql/database/saas-tenancy-app-design-patterns?view=azuresql">Multi-tenant SaaS database tenancy patterns</a> - Azure, 20230304</li><li><a href="https://www.nagarro.com/en/blog/multi-tenant-saas-application-architecture">Architecting a typical Multi-tenant SaaS Application – All you need to know</a></li><li><a href="https://web.archive.org/web/20150221181153/http://se2.informatik.uni-wuerzburg.de/pa/uploads/papers/paper-371.pdf">Architectural Concerns in Multi-Tenant SaaS Applications</a></li><li><a href="https://www.forbes.com/sites/forbesbusinesscouncil/2019/11/20/what-is-the-saas-architecture-maturity-model/?sh=4196006c4b40">What Is The SaaS Architecture Maturity Model?</a></li></ul></li><li>K8s 相關<ul><li><a href="https://github.com/kubernetes-sigs/multi-tenancy">K8s Multi-tenancy 小組</a></li><li><a href="https://kubernetes.io/blog/2021/04/15/three-tenancy-models-for-kubernetes/">Three Tenancy Models For Kubernetes</a></li><li><a href="https://thenewstack.io/designing-a-multitenancy-kubernetes-strategy-that-fits-your-organization/">Designing a Multitenancy Kubernetes Strategy that Fits Your Organization</a></li></ul></li><li>資料庫相關<ul><li><a href="https://vladmihalcea.com/database-multitenancy/">A beginner’s guide to database multitenancy</a>, 20200917</li><li><a href="https://oncodedesign.com/data-isolation-and-sharing-in-multitenant-system-part1/">Data Isolation and Sharing in a Multitenant System - Part 1</a></li><li><a href="https://oncodedesign.com/data-isolation-and-sharing-in-multitenant-system-part1/">Data Isolation and Sharing in a Multitenant System - Part 2</a></li><li><a href="https://oncodedesign.com/data-isolation-and-sharing-in-multitenant-system-part1/">Data Isolation and Sharing in a Multitenant System - Part 3</a></li></ul></li><li>AWS<ul><li><a href="https://www.nagarro.com/en/blog/architectural-design-patterns-aws-multi-tenancy">Architectural design patterns for multi-tenancy on AWS</a></li><li><a href="https://aws.amazon.com/blogs/machine-learning/configure-amazon-forecast-for-a-multi-tenant-saas-application/">Configure Amazon Forecast for a multi-tenant SaaS application</a> - AWS Machine Learning Blog, 20210325</li><li><a href="https://aws.amazon.com/blogs/security/how-to-implement-saas-tenant-isolation-with-abac-and-aws-iam/">How to implement SaaS tenant isolation with ABAC and AWS IAM</a> - AWS Security Blog, 20210609</li><li><a href="https://aws.amazon.com/tw/blogs/storage/ten-tips-for-multi-tenant-multi-region-object-replication-in-amazon-s3/">Ten tips for multi-tenant, multi-Region object replication in Amazon S3</a> - AWS Storage Blog, 20211101</li><li><a href="https://aws.amazon.com/blogs/database/build-and-load-test-a-multi-tenant-saas-database-proxy-solution-with-amazon-rds-proxy/">Build and load test a multi-tenant SaaS database proxy solution with Amazon RDS Proxy</a> - AWS Database Blog, 20211113</li><li><a href="https://aws.amazon.com/cn/blogs/china/saas-architecture-design-on-amazon-cloud-technology-marketplace-how-to-support-multiple-products-using-a-single-account-center/">在亚马逊云科技Marketplace上的SaaS架构设计——如何支持多产品使用单一账户中心</a> - 20210813</li><li><a href="https://aws.amazon.com/blogs/apn/isolating-saas-tenants-with-dynamically-generated-iam-policies/">Isolating SaaS Tenants with Dynamically Generated IAM Policies</a> - AWS Partner Network (APN) Blog, 20200921</li><li><a href="https://theburningmonk.com/2021/03/how-to-secure-multi-tenant-applications-with-appsync-and-cognito/">How to secure multi-tenant applications with AppSync and Cognito</a></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;多租戶架構 (Mulit-Tenancy Architecture, 以下稱作 MTA)&lt;/code&gt; 是 &lt;code&gt;SaaS (Software as a Service, 軟體及服務)&lt;/code&gt; 設計的核心議題，也是我過去幾年工作研究的題目之一，大部分的人針對這個題目討論的多是 K8s 的 Namespace 劃分、或者資料庫的拆分方式、使用 Single or Shared &amp;#x2F; Hybrid … 等策略。&lt;/p&gt;
&lt;p&gt;多租戶架構背後需要討論的，除了這些技術架構的議題，更重要的是往前一步：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;SaaS 的 &lt;code&gt;多租戶&lt;/code&gt; 應該怎麼定義？以及能夠解決那些問題？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;基於這些討論與實踐，最後我提出設計 MTA 的關鍵抽象概念，我把它稱為 &lt;code&gt;Isolation Factor (隔離因子)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;這篇文章嘗試解釋與探討 &lt;code&gt;多租戶&lt;/code&gt; 背景與核心議題，同時用真實世界的租賃關係，剖析設計 SaaS 時必須要知道的概念，嘗試帶出 Isolation Factor 的重要性。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;相關文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2022/07/04/DistributedSystems/Inspired-Design-From-Eclipse/&quot;&gt;摘要 Eclipse 設計的啟發：當代 SaaS 分散式架構的關鍵設計&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2023/06/24/DistributedSystems/API-First_Communication-Protocol/&quot;&gt;API 設計 - 摘要 API 通訊模式與協議&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2021/05/14/DistributedSystems/Service-Governance/&quot;&gt;聊聊分散式架構的服務治理&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Distributed Systems" scheme="https://rickhw.github.io/categories/Distributed-Systems/"/>
    
    
    <category term="Distributed Systems" scheme="https://rickhw.github.io/tags/Distributed-Systems/"/>
    
    <category term="Design Thinking" scheme="https://rickhw.github.io/tags/Design-Thinking/"/>
    
    <category term="Multi-Tenancy" scheme="https://rickhw.github.io/tags/Multi-Tenancy/"/>
    
    <category term="SaaS" scheme="https://rickhw.github.io/tags/SaaS/"/>
    
    <category term="Isolation Factor" scheme="https://rickhw.github.io/tags/Isolation-Factor/"/>
    
    <category term="Multi-Tenancy Architecture" scheme="https://rickhw.github.io/tags/Multi-Tenancy-Architecture/"/>
    
    <category term="RBAC" scheme="https://rickhw.github.io/tags/RBAC/"/>
    
    <category term="Authorization" scheme="https://rickhw.github.io/tags/Authorization/"/>
    
  </entry>
  
  <entry>
    <title>探索職涯、複利人生 - AWS Career Exploration Day 2023</title>
    <link href="https://rickhw.github.io/2023/09/09/About/2023-AWS-Career-Exploration-Day/"/>
    <id>https://rickhw.github.io/2023/09/09/About/2023-AWS-Career-Exploration-Day/</id>
    <published>2023-09-09T13:42:30.000Z</published>
    <updated>2025-10-20T12:43:51.152Z</updated>
    
    <content type="html"><![CDATA[<p>去年 (2022) 受邀 <a href="/2022/12/21/About/2022-AWS-Career-Exploration-Day/">AWS Career Exploration Day</a> 分享職涯的想法，今年因為個人因素，無法到現場。但是在主辦單位熱情的邀約以及協助下，改用錄影的方式，延續去年分享的想法～</p><blockquote><p>Updated: 20231122 媒體的報導: <a href="https://buzzorange.com/techorange/2023/11/20/aws-career-day/">迎向 AI 與雲端共融世代，如何校準自身技能成長策略？</a></p></blockquote><span id="more"></span><h2 id="Slide-與錄影"><a href="#Slide-與錄影" class="headerlink" title="Slide 與錄影"></a>Slide 與錄影</h2><iframe src="https://www.slideshare.net/slideshow/embed_code/key/H7csbb3oDH5PT3?startSlide=1" width="597" height="486" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px;max-width: 100%;" allowfullscreen></iframe><div style="margin-bottom:5px"><strong><a href="https://www.slideshare.net/rickhwang/20230829" title="20230829 - 探索職涯，複利人生" target="_blank">20230829 - 探索職涯，複利人生</a></strong> from <strong><a href="https://www.slideshare.net/rickhwang" target="_blank">Rick Hwang</a></strong></div><p>這次不一樣的是，我自己錄影的同時，也自己嘗試剪接與後製，底下是我自己 (導演版？) 的版本：</p><iframe width="560" height="315" src="https://www.youtube.com/embed/V5eM-Uwd9x4?si=kxKZUOnuXNPWmCU7" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe><hr><h2 id="重點摘要"><a href="#重點摘要" class="headerlink" title="重點摘要"></a>重點摘要</h2><p>延續去年的分享，也延續我在 <a href="/2023/07/17/About/2023-SRE-Practice-and-IDP/">SRE 新書書友見面會</a> 的分享，整合了過去自己的經歷、朋友遭遇的問題，整理出以下的想法：</p><ol><li>面對職涯轉換的應對與心境</li><li>探索自己，充實自己</li><li>決策職涯，複利人生</li></ol><p><img src="/images/About/2023-AWSCareerExplorationDay/Slide1.png"><br><img src="/images/About/2023-AWSCareerExplorationDay/Slide2.png"><br><img src="/images/About/2023-AWSCareerExplorationDay/Slide3.png"><br><img src="/images/About/2023-AWSCareerExplorationDay/Slide4.png"><br><img src="/images/About/2023-AWSCareerExplorationDay/Slide5.png"></p><hr><h2 id="朋友的-Feedback"><a href="#朋友的-Feedback" class="headerlink" title="朋友的 Feedback"></a>朋友的 Feedback</h2><p>影片上架後，當天朋友的 Feedback。</p><p><img src="/images/About/2023-AWSCareerExplorationDay/feedback1_20230830.jpeg"></p><p>歡迎分享你的經驗，或者私訊我你的故事，讓更多人知道，職涯的路，並不孤單。</p><h2 id="相關文章"><a href="#相關文章" class="headerlink" title="相關文章"></a>相關文章</h2><ul><li><a href="https://youtu.be/Q4SqoDu9xns?si=DTiwEcxtWcM--tWh">[EP01] 職涯選擇：面試你的主管</a></li><li><a href="/2023/07/17/About/2023-SRE-Practice-and-IDP/">個人著作《SRE 實踐與開發平台指南》</a></li><li><a href="/2022/12/21/About/2022-AWS-Career-Exploration-Day/">AWS Career Exploration Day 2022</a></li><li><a href="/2019/08/14/About/About-Certificate/">證照有無用論？</a></li><li><a href="/2018/08/20/Management/Overview-Hiring/">聊聊人力招募</a></li><li><a href="/2021/09/10/About/Self-Exploration/">職涯、探索、退休</a></li><li><a href="/2020/06/21/Management/Interview-Problems/">面試常見的問題</a></li><li><a href="/2017/09/20/About/Learning-Approaches/">學習法則</a></li><li><a href="/2016/10/01/AWS-Study-Roadmap/">AWS Study Roadmap</a></li><li><a href="/2016/08/20/AWS/AWS-Certified-Developer/">AWS Certified Developer - Associate 準備心得</a></li><li><a href="/2016/07/29/AWS/AWS-Certified-SysOps-Administrator/">AWS Certified SysOps Administrator - Associate 準備心得</a></li><li><a href="/2016/04/22/AWS/AWS-Certified-Solutions-Architect_Associate/">AWS Certified Solutions Architect - Associate 準備心得</a></li><li><a href="/2019/01/12/About/Talent-And-Effort/">天賦與努力</a></li><li><a href="https://buzzorange.com/techorange/2024/03/21/a-tech-entrepreneur-shared-the-advice-steve-jobs-once-gave-him/">做自己熱愛的事！賈伯斯演講啟發這位創業家 20 年，幫助他把挑戰變令人興奮的冒險</a></li><li><a href="https://podcasts.apple.com/tw/podcast/%E8%81%B7%E6%B6%AF%E5%B1%A5%E8%A1%8C%E5%AE%B6-creating-our-future/id1546960737?i=1000657648576">IKIGAI 是什麼？四個問題找到天命 - 人類圖進階課！從 11 個閘門看基因天命，找到貢獻世界的地方！專訪 人類設計 Lifestyle 創辦人Ray</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;去年 (2022) 受邀 &lt;a href=&quot;/2022/12/21/About/2022-AWS-Career-Exploration-Day/&quot;&gt;AWS Career Exploration Day&lt;/a&gt; 分享職涯的想法，今年因為個人因素，無法到現場。但是在主辦單位熱情的邀約以及協助下，改用錄影的方式，延續去年分享的想法～&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Updated: 20231122 媒體的報導: &lt;a href=&quot;https://buzzorange.com/techorange/2023/11/20/aws-career-day/&quot;&gt;迎向 AI 與雲端共融世代，如何校準自身技能成長策略？&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="經營管理" scheme="https://rickhw.github.io/categories/%E7%B6%93%E7%87%9F%E7%AE%A1%E7%90%86/"/>
    
    <category term="Career" scheme="https://rickhw.github.io/categories/%E7%B6%93%E7%87%9F%E7%AE%A1%E7%90%86/Career/"/>
    
    
    <category term="AWS" scheme="https://rickhw.github.io/tags/AWS/"/>
    
    <category term="Career" scheme="https://rickhw.github.io/tags/Career/"/>
    
    <category term="Certiciation" scheme="https://rickhw.github.io/tags/Certiciation/"/>
    
  </entry>
  
  <entry>
    <title>凝聚團隊共識的溝通方法</title>
    <link href="https://rickhw.github.io/2023/08/13/Management/Effective-Team-Communication/"/>
    <id>https://rickhw.github.io/2023/08/13/Management/Effective-Team-Communication/</id>
    <published>2023-08-13T01:33:00.000Z</published>
    <updated>2025-10-20T12:54:16.048Z</updated>
    
    <content type="html"><![CDATA[<p>這篇整理自今年二月跟朋友分享的內容，主要是關於溝通效率的目錄、總整理。</p><span id="more"></span><h1 id="總整理"><a href="#總整理" class="headerlink" title="總整理"></a>總整理</h1><iframe src="https://www.slideshare.net/slideshow/embed_code/key/DX860wz54CRPEC?startSlide=1" width="597" height="486" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px;max-width: 100%;" allowfullscreen></iframe><div style="margin-bottom:5px"><strong><a href="https://www.slideshare.net/rickhwang/20230215-effective-team-communicationpdf" title="20230215 - 凝聚團隊共識的溝通方法 (Effective Team Communication)" target="_blank">20230215 - 凝聚團隊共識的溝通方法 (Effective Team Communication)</a></strong> from <strong><a href="https://www.slideshare.net/rickhwang" target="_blank">Rick Hwang</a></strong></div><h2 id="溝通原理"><a href="#溝通原理" class="headerlink" title="溝通原理"></a>溝通原理</h2><p><img src="/images/Communication/Effective-Team-Communication/07-purpose.png"><br><img src="/images/Communication/Effective-Team-Communication/01-principle.png"><br><img src="/images/Communication/Effective-Team-Communication/02-request.png"><br><img src="/images/Communication/Effective-Team-Communication/03-response.png"><br><img src="/images/Communication/Effective-Team-Communication/04-many-to-many.png"><br><img src="/images/Communication/Effective-Team-Communication/05-one-to-many.png"><br><img src="/images/Communication/Effective-Team-Communication/06-one-to-one.png"></p><h2 id="常見的衝突"><a href="#常見的衝突" class="headerlink" title="常見的衝突"></a>常見的衝突</h2><p><img src="/images/Communication/Effective-Team-Communication/13-talk-with.png"><br><img src="/images/Communication/Effective-Team-Communication/08-conflict.png"><br><img src="/images/Communication/Effective-Team-Communication/10-conflict-wo-listen.png"><br><img src="/images/Communication/Effective-Team-Communication/11-too-many-request.png"><br><img src="/images/Communication/Effective-Team-Communication/09-simple-point.png"></p><p><img src="/images/Communication/Effective-Team-Communication/12-quality.png"></p><h2 id="會議：最常見的溝通場合"><a href="#會議：最常見的溝通場合" class="headerlink" title="會議：最常見的溝通場合"></a>會議：最常見的溝通場合</h2><p><img src="/images/Communication/Effective-Team-Communication/14-meeting-before.png"><br><img src="/images/Communication/Effective-Team-Communication/15-meeting-ing.png"><br><img src="/images/Communication/Effective-Team-Communication/16-meeting-after.png"><br><img src="/images/Communication/Effective-Team-Communication/17-meeting-problems.png"><br><img src="/images/Communication/Effective-Team-Communication/18-effecitve-meeting.png"></p><hr><h1 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h1><h2 id="溝通"><a href="#溝通" class="headerlink" title="溝通"></a>溝通</h2><ul><li><a href="/2020/03/24/Management/Principles-of-Communication/">溝通的原理</a></li><li><a href="/2014/12/10/Management/%E6%BA%9D%E9%80%9A-%E6%88%90%E6%9C%AC/">溝通 &#x3D; 成本</a></li><li><a href="/2020/08/01/Management/Expression-and-Communication/">表達與溝通的差異</a></li><li><a href="/2023/07/29/Management/Team-Consensus-and-Talent-Development/">凝聚團隊共識與人才養成</a></li><li><a href="/2021/12/19/Management/Protocol-to-Communication/">團隊溝通的通訊協議</a></li><li><a href="/2023/08/13/Management/Effective-Team-Communication/">凝聚團隊共識的溝通方法</a></li><li><a href="/2018/03/18/SQA/How-To-Report-A-Defect-or-Bug/">如何有效的回報問題</a></li><li><a href="/2023/08/01/Management/PERMA/">1 on 1 聊什麼 - PERMA</a></li></ul><h2 id="會議"><a href="#會議" class="headerlink" title="會議"></a>會議</h2><ul><li><a href="/2014/11/26/Management/%E9%96%8B%E6%9C%83%E5%8E%9F%E5%89%87/">開會原則</a></li><li><a href="/2020/10/11/Management/Effective-Meetings/">一場有效的會議</a></li><li><a href="/2023/06/14/Management/Failed-Meeting/">一場失敗會議</a></li><li><a href="/2019/08/25/Management/Problems-of-Meeting/">會議的普遍現象</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;這篇整理自今年二月跟朋友分享的內容，主要是關於溝通效率的目錄、總整理。&lt;/p&gt;</summary>
    
    
    
    <category term="經營管理" scheme="https://rickhw.github.io/categories/%E7%B6%93%E7%87%9F%E7%AE%A1%E7%90%86/"/>
    
    <category term="溝通" scheme="https://rickhw.github.io/categories/%E7%B6%93%E7%87%9F%E7%AE%A1%E7%90%86/%E6%BA%9D%E9%80%9A/"/>
    
    
    <category term="溝通" scheme="https://rickhw.github.io/tags/%E6%BA%9D%E9%80%9A/"/>
    
    <category term="Meetings" scheme="https://rickhw.github.io/tags/Meetings/"/>
    
    <category term="時間管理" scheme="https://rickhw.github.io/tags/%E6%99%82%E9%96%93%E7%AE%A1%E7%90%86/"/>
    
    <category term="會議原則" scheme="https://rickhw.github.io/tags/%E6%9C%83%E8%AD%B0%E5%8E%9F%E5%89%87/"/>
    
    <category term="會議效率" scheme="https://rickhw.github.io/tags/%E6%9C%83%E8%AD%B0%E6%95%88%E7%8E%87/"/>
    
    <category term="溝通成本" scheme="https://rickhw.github.io/tags/%E6%BA%9D%E9%80%9A%E6%88%90%E6%9C%AC/"/>
    
    <category term="工作管理" scheme="https://rickhw.github.io/tags/%E5%B7%A5%E4%BD%9C%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>1 on 1 聊什麼 - PERMA</title>
    <link href="https://rickhw.github.io/2023/08/01/Management/PERMA/"/>
    <id>https://rickhw.github.io/2023/08/01/Management/PERMA/</id>
    <published>2023-08-01T10:21:00.000Z</published>
    <updated>2025-10-20T12:44:32.383Z</updated>
    
    <content type="html"><![CDATA[<p>這篇整理自 2022&#x2F;10&#x2F;12 <code>Software Engineering at Google</code> 這本書的讀書會的 <a href="https://www.facebook.com/rick.kyhwang/posts/pfbid0244LFy2CbbY2GuWzL8j1aBJqWATcvqBAsnshgdW6sVrnnwTij6EdmFcC4eKYRDrPwl">筆記與摘要</a>。</p><span id="more"></span><hr><h2 id="1-on-1-的目的？"><a href="#1-on-1-的目的？" class="headerlink" title="1 on 1 的目的？"></a>1 on 1 的目的？</h2><p>主管需要定期跟團隊同仁 1 on 1，目的除了了解同仁的工作狀況，更進一步的是了解他們遇到的困難，適度地伸出援手，協助同仁成長。</p><p>過去 1 on 1 的經驗，有兩個題目是更多同仁需要的：</p><ol><li><code>工作的方向</code>: 工作方向通常會導向 <code>職涯規劃</code>，背後動機是希望大家對於現況是否滿意，如果不滿意，那滿意是什麼？這個探索過的，大多都跟職涯方向有關係。<ul><li>對於主管而言，探索的動機是風險管理，如果這位同仁對於工作內容，有疑慮，甚至是在騎驢找馬，這些都是 1 on 1 過程可以觀察出來的。</li><li>身為主管，應該要正面面對可能正在騎驢找馬的同仁，評估如何協助他，另外就是要做好後續的準備。如果他真的有異動，那團隊任務的調度應該如何處理，更多參閱 <a href="/2019/07/09/Management/Layoff-Fired-Resiging/">管理必經之路：資遣、解僱、辭呈</a></li><li>引導職涯方向的討論，可以參閱 <a href="/2022/12/21/About/2022-AWS-Career-Exploration-Day/">AWS Career Exploration Day 2022</a> </li><li>組織人才佈局與管理策略，可以參閱 <a href="https://www.facebook.com/rick.kyhwang/posts/pfbid0tWjKzm9BnagRqknGrnXfzA2DbqTCq1xCcFTdZjvRtkA2pu1rLSbpvfsYGFAe9Mtdl">人才發展策略地圖 (draft)</a></li></ul></li><li><code>工作與生活的平衡</code>: <a href="/2022/10/15/Management/Problem-Behind-Question/">背後深層的問題</a> 我認為是 - <code>幸福感</code></li></ol><p>幸福感這種題目在職場上是很少被拿出來討論的，辦公室裡大多是血淋淋的廝殺，爾虞我詐，各種政治問題。但因為這些利益糾葛，卻往往讓大家忘了一個很重要的問題：</p><blockquote><p>工作的目的到底是什麼？</p></blockquote><p>不管是怎樣的目的，我覺得最終的答案應該是：</p><blockquote><p>讓自己生活更幸福</p></blockquote><p>幸福感談起來很雞湯、高大尚、甚至空泛，有時候在職場上，談這個題目可能會被誤解，或者被質疑背後的動機。</p><p>動機一定是有的，就是前面提到的風險管理，這也是主管的職責。但是基於不過問個人隱私的原則，例如個人的家庭、婚姻、感情、健康 … 等，只要不影響任務，基本上主管是沒有權利過問的，過去我個人也幾乎不會過問這些問題。但這點是矛盾的，每個人難免都會因為個人因素的形況，影響工作狀況。主管用怎樣的方法，不會讓同仁不會覺得有威脅、侵入，可以建立信任，同時又可以協助彼此，找到幸福感，至一個好主管必要的能力。</p><p>習慣用指標方法有效溝通，所以一次同事的介紹之下，接觸了被譽為 <code>正向心理學之父</code>，美國著名心理學家 <a href="https://zh.wikipedia.org/zh-tw/%E9%A9%AC%E4%B8%81%C2%B7%E8%B5%9B%E9%87%8C%E6%A0%BC%E6%9B%BC">馬丁塞利格曼</a>，提出的方法論 PERMA，讓我有了具體探索的方式。</p><p>後來我就把這個方法引入 1 on 1 的過程，底下這段是某次內部讀書會時，分享過去我怎麼 1 on 1 的紀錄。</p><h2 id="職場上的幸福感"><a href="#職場上的幸福感" class="headerlink" title="職場上的幸福感"></a>職場上的幸福感</h2><p>聊到 Engineering Manager (管人) 怎麼知道同仁工作的 <code>幸福感</code> ？我常用的方法是 <a href="https://medium.com/psychology-wonderland/perma%E5%B9%B8%E7%A6%8F%E4%BA%94%E5%85%83%E7%B4%A0-200bce958fa9">PERMA</a>，這五個字分別是以下的縮寫：</p><ol><li>Postive Emotions 正向情緒</li><li>Engagement 全心投入</li><li>Positive Relationship 正向人際關係</li><li>Meaning 生命的意義</li><li>Accomplishment 成就感</li></ol><p><img src="/images/Management/PERMA/PERMA.png"><br>詳細參閱：<a href="https://medium.com/psychology-wonderland/perma%E5%B9%B8%E7%A6%8F%E4%BA%94%E5%85%83%E7%B4%A0-200bce958fa9">PERMA幸福五元素 - 幸福也有公式，建立這些元素讓你活得更幸福</a></p><p>我會用這五個指標，加上 <code>工作</code> 與 <code>生活</code> 兩個象限，如此就有十個指標，每個指標 (bad) 1-10 (good) 分，給同仁一點時間，在白板上寫下自己過去一個月 或一季 以來的分數。如下圖是某一次跟同仁一起討論的紀錄：</p><p><img src="/images/Management/PERMA/20211029.jpg"></p><p>透過這個方法，討論彼此對於每個指標自己在工作或生活的定義或者理解，然後根據現在的狀況，討論分數為什麼是那樣，進而找到目前是幸福指數。</p><p>這個過程，主管的身份，主要會針對工作討論，這是責任、也是權利。逐項跟同仁討論分數背後的原因，例如正向情緒是七分，怎麼是這個分數？哪個事情導致評分？那五分有可能是哪個分數？這是平均值？ … 等。一個正向情緒就可以聊很多東西，看時間狀況，可以挑著聊，像是挑分數比較低的，請對方說說分數背後的故事。這個過程往往會探索出很多問題，這些問題是身為主管要協助同仁改善與提供幫助的。</p><p>工作的分數是主管需要深入了解的，個人部分就可以看同仁狀況。通常個人分數我選擇讓同仁自己保留，但如果分數很低，我大多不會直接問，而是直接說：</p><blockquote><p>有我幫的上的地方，就讓我知道</p></blockquote><p>經驗上，經過幾次工作分數的討論，大多同仁已經知道我的動機，而且知道這是加深彼此的信任。所以個人狀況比較願意跟主管討論，進而避免因為個人因素，影響工作。</p><p>這個方法其實也可以當作自己跟親友評量的工具，透過這個方法更了解彼此。</p><h2 id="全心投入"><a href="#全心投入" class="headerlink" title="全心投入"></a>全心投入</h2><p>其中個人最在乎的就是 <code>Engagement (全心投入)</code>，也就是工作有沒 <code>心流狀態</code>。例如跟同仁的討論設計，有沒真正意義上在討論設計內容，討論過程沒有頭銜、沒有年紀、沒有職級，彼此以客觀、專業的角度，交流想法。</p><p>一個人寫程式，很容易有這種交流，但是卻是單向的，只跟機器溝通，只跟工具交流。但是跟團隊討論設計的過程，大家從各自的角度，客觀地把想法說出來，然後一起激盪出一個大家都覺得 OK 的設計，這個過程，沒有頭銜、沒有組織隔閡、不是為了 KPI，只有共同目標，這點是我覺得很難得的，也是工作中最享受的部分。</p><p>在之前工作，有過很深度 <code>全心投入</code> 的感覺，還記得把產品打造出來，經歷不知道幾回合反覆驗證、找問題、討論 (包含吵架)、修正，最後東西做出來了，到工廠協助量產測試 (NPI)，確立生產測試流程、IQC，還有設計師設計的包裝彩盒。如下圖：</p><p><img src="/images/Management/PERMA/oplink-prod1.jpg"><br><img src="/images/Management/PERMA/oplink-prod2.jpg"></p><p>當拿到工廠生產出來的產品，彩盒開箱的那一刻，心情真的是難以言喻。這麼多年過去了，之後就很難再有那種全心投入，整個團隊一起努力好一件事情的感覺。</p><blockquote><p>全心投入相反的狀態就是 <a href="/2017/01/23/Management/Cost-In-Context-Switch/">Context Switch</a>.</p></blockquote><hr><h1 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h1><h2 id="站內文章"><a href="#站內文章" class="headerlink" title="站內文章"></a>站內文章</h2><ul><li><a href="/2022/12/21/About/2022-AWS-Career-Exploration-Day/">AWS Career Exploration Day 2022</a></li><li><a href="/2022/10/15/Management/Problem-Behind-Question/">Problem Behind Question</a></li><li><a href="https://www.facebook.com/rick.kyhwang/posts/pfbid0tWjKzm9BnagRqknGrnXfzA2DbqTCq1xCcFTdZjvRtkA2pu1rLSbpvfsYGFAe9Mtdl">人才發展策略地圖 (draft)</a></li><li><a href="/2017/01/23/Management/Cost-In-Context-Switch/">Cost in Context Switch</a></li><li><a href="/2019/07/09/Management/Layoff-Fired-Resiging/">管理必經之路：資遣、解僱、辭呈</a></li></ul><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul><li><a href="https://medium.com/psychology-wonderland/perma%E5%B9%B8%E7%A6%8F%E4%BA%94%E5%85%83%E7%B4%A0-200bce958fa9">PERMA幸福五元素 - 幸福也有公式，建立這些元素讓你活得更幸福</a></li><li><a href="https://podcasts.apple.com/tw/podcast/%E5%8A%89%E8%BB%92%E7%9A%84how-to%E4%BA%BA%E7%94%9F%E5%AD%B8/id1547950387?i=1000602953940">EP198｜【讀書會】心理學從此改變的那一刻 ——《Flourish 邁向圓滿》</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;這篇整理自 2022&amp;#x2F;10&amp;#x2F;12 &lt;code&gt;Software Engineering at Google&lt;/code&gt; 這本書的讀書會的 &lt;a href=&quot;https://www.facebook.com/rick.kyhwang/posts/pfbid0244LFy2CbbY2GuWzL8j1aBJqWATcvqBAsnshgdW6sVrnnwTij6EdmFcC4eKYRDrPwl&quot;&gt;筆記與摘要&lt;/a&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="經營管理" scheme="https://rickhw.github.io/categories/%E7%B6%93%E7%87%9F%E7%AE%A1%E7%90%86/"/>
    
    <category term="Career" scheme="https://rickhw.github.io/categories/%E7%B6%93%E7%87%9F%E7%AE%A1%E7%90%86/Career/"/>
    
    
    <category term="溝通" scheme="https://rickhw.github.io/tags/%E6%BA%9D%E9%80%9A/"/>
    
    <category term="Bus Memo" scheme="https://rickhw.github.io/tags/Bus-Memo/"/>
    
    <category term="主管" scheme="https://rickhw.github.io/tags/%E4%B8%BB%E7%AE%A1/"/>
    
    <category term="PERMA" scheme="https://rickhw.github.io/tags/PERMA/"/>
    
    <category term="正向心理學" scheme="https://rickhw.github.io/tags/%E6%AD%A3%E5%90%91%E5%BF%83%E7%90%86%E5%AD%B8/"/>
    
  </entry>
  
  <entry>
    <title>凝聚團隊共識與人才養成</title>
    <link href="https://rickhw.github.io/2023/07/29/Management/Team-Consensus-and-Talent-Development/"/>
    <id>https://rickhw.github.io/2023/07/29/Management/Team-Consensus-and-Talent-Development/</id>
    <published>2023-07-29T10:21:00.000Z</published>
    <updated>2025-10-20T12:57:25.581Z</updated>
    
    <content type="html"><![CDATA[<p>這段 <a href="https://www.facebook.com/rick.kyhwang/posts/pfbid0gwDFvZ2RnZvTsFoo9bHgG5Hmfhs31953kjZa5MX3aj7jfrB6AsfaootqgcYM1Td7l">筆記</a> 是 2020 年聽 podcast 寫下的心得筆記、跟朋友討論的東西。這整個過程，也是我過去 <code>凝聚團隊共識</code>、<code>人才養成</code> 的實踐方法。</p><span id="more"></span><h2 id="階段"><a href="#階段" class="headerlink" title="階段"></a>階段</h2><p>這是我在團隊裡用了一段時間、找共識的方法</p><ul><li>第一階段是 <code>暢所欲言</code>，誰有什麼想法都提出來寫下來；</li><li>第二階段是 <code>評估想法</code>，發現不同想法之間的聯繫，把他們用線連接起來；</li><li>第三階段是 <code>形成決議</code>：把討論中淘汰掉的想法都劃掉，剩下的分出 <code>主、次</code> 和 <code>執行順序</code>，然後整理一下就可以照著做了。</li></ul><p>這三個階段，其實就是從 <code>發散思維</code>，到最後 <code>集體的集中思維</code> 的過程。先發揚民主，最後形成集中的共識。</p><h2 id="起頭：萬事起頭難，暢所欲言"><a href="#起頭：萬事起頭難，暢所欲言" class="headerlink" title="起頭：萬事起頭難，暢所欲言"></a>起頭：萬事起頭難，暢所欲言</h2><p>通常要有人起頭，做個雛形或者樣子，然後要讓大家暢所欲言的討論，把想法丟出來，這段過程很重要。</p><p>我常會是把想法丟出來的人，但是跟大家發想的過程，要準備被大家圍毆，或者被整個推翻的心理準備。這個過程要放下身份、身段，讓大家可以 <code>暢所欲言</code>，然後透過這樣的激盪，把想法都放在白板上，過程用顏色區分問題、方向、現況 … 等。</p><p>而在討論過程，主軸很容易因為大家的背景、角色、經驗不一樣，主軸一直 <code>飄、亂、散</code> 是正常的，所以一開始發起的人就是要負責讓會議進行有主軸。</p><blockquote><p>這個過程，雖然是我先發起，但過程中也可以探索出下一個可以接棒自己的人才，越有想法的人，就讓他嘗試起頭。<br>相關文章：<a href="/2022/09/10/About/Difficult-and-Complicate/">問題的難與雜</a></p></blockquote><h2 id="探索潛力人才"><a href="#探索潛力人才" class="headerlink" title="探索潛力人才"></a>探索潛力人才</h2><p>下一步就是要指派一個負責人，開始整理白板討論的內容，通常他也是接下來整個任務的執行者。</p><p>這段非常非常重要，因為 <code>整理</code> 就是把想法具象化的過程，沒有這段整理的過程，討論過程激盪的想法與內容等於就浪費了。</p><p>接手的人要負責整理這些討論的內容，把發散的資訊，眾人的想法，收斂成一份大家的初版共識。</p><p>整理的過程，負責人必須重新深度思考這些討論，重新思考其中的 <code>邏輯結構</code>、<code>先後關係</code>、<code>必要與次要</code>，經過這段重新思考，這個人會變成對整件有最深刻的了解。</p><h2 id="可執行的規格與計畫"><a href="#可執行的規格與計畫" class="headerlink" title="可執行的規格與計畫"></a>可執行的規格與計畫</h2><p>下一步就是整理成有意義的文件，這份文件會是一份 Guideline、Spec 的草稿版了。這份文件也會是未來執行的起始點，文件內容包含：</p><ol><li>問題的描述</li><li>目標，得到的好處</li><li>解決方案有哪些？他們個別考慮是什麼？適合怎樣的場景？優缺點</li><li>具體 PoC 的範圍</li><li>常見的問題</li></ol><p>有了規格的具象化，下一步才是技術的實驗，也就是 PoC。依據目標與方向的 PoC 才有意義。否則很容易變成無上限的發散。</p><blockquote><p>這個過程有點類似：<a href="/2019/04/05/About/Working-Backwards/">Working Backwards</a> 的想法</p></blockquote><h2 id="透過技術評估，培養技術專家"><a href="#透過技術評估，培養技術專家" class="headerlink" title="透過技術評估，培養技術專家"></a>透過技術評估，培養技術專家</h2><p>紙上得來終覺淺，絕知此事要躬行。再多的討論與想法，沒有人動手去做，終究空談，特別是在技術圈。</p><p>所以前面提到的負責人，通常會是實際執行的人，他也會是未來對這個新任務、新技術最熟的人，這是培養技術專家的機會與跳板。</p><p>PoC 技術是要解決現場問題。所以根據規格的內容，開始評估需要的技術與 PoC，他要走過所有技術的實踐與考慮，過程就是對於新技術有駕馭能力，獨立研究新技術的方向、如何評估可行性。</p><p>現場問題往往比 PoC 的更複雜十倍。但是 PoC 是要了解是否都滿足現場的考量，我常會說：問題的 Consideration (考慮) 是什麼？這些考慮都是必要的？優先續是什麼？</p><p>評估過程，不管結果怎樣，只要確實執行，對於技術會有基礎掌握。掌握技術的目的是為了能夠解決關鍵問題，帶來效益。不管評估結果是否適合，都是毀很有收穫的。</p><blockquote><p>2018 年 K8s 剛開始流行的時候，因為團隊需求，期望 K8s 上跑 Windows Container，但我們都知道，這是不切實際的。但我們還是很認真的評估，花了兩個多月，找了 AWS EKS (那時候 EKS 還在 Beta) 一起評估，搞了很久，但有了實際的報告與預期結果。最後結果不難猜想，是不適合的 (不是不行)，但是大家都因為這個評估過程，很有收穫。</p></blockquote><p>除了技術評估，過程我也會訓練同仁 <code>表達</code> 能力，也就是 <code>把複雜的技術概念，變成普羅大眾能聽懂的人話</code>，就像是科普一樣。背後目的就是讓他試著把技術講易懂，怎樣找到適當的比喻，怎樣讓另一個人也懂的怎麼做？怎麼用？怎麼講？<code>表達</code> 技巧也是訓練的關鍵之一。懂技術，會用技術，但是無法讓別人知道，等於不懂。</p><blockquote><p>沒有時間學習技術的管理者，也可以在這個過程，間接學到這些新技術，至少不會完全跟不上，相關參閱 <a href="/2019/03/30/Management/How-do-Manager-Keep-Learning/">管理者如何持續學習技術？</a>, <a href="https://www.facebook.com/rick.kyhwang/posts/pfbid0tWjKzm9BnagRqknGrnXfzA2DbqTCq1xCcFTdZjvRtkA2pu1rLSbpvfsYGFAe9Mtdl">人才發展策略地圖 (draft)</a></p></blockquote><h2 id="下一步：執行與落地"><a href="#下一步：執行與落地" class="headerlink" title="下一步：執行與落地"></a>下一步：執行與落地</h2><p>透過評估，滿足了所有情境，下一步才是導入。導入就是真的拿去用，解決問題，產生價值。</p><p>用之前，我通常會希望有規則，也就是 <code>使用前請閱讀公開說明書的概念</code>。</p><p><code>能</code> 是一件事，<code>用</code> 另一件事。評估與 PoC 確定的是 <code>能</code> 的問題，<code>用</code> 是要用 <code>制度、規範</code> 解決。</p><p>制度規範就是規矩，沒有規矩，怎麼能方圓？系統要長大，線性增加，靠的是規矩、制度、章法。</p><blockquote><p>更多參閱： <a href="/2019/11/19/Management/Objectives-Key-Results-Executions/">有效定義目標與執行、落地</a></p></blockquote><h2 id="Q-怎麼讓來開會的人有暢所欲言？"><a href="#Q-怎麼讓來開會的人有暢所欲言？" class="headerlink" title="Q: 怎麼讓來開會的人有暢所欲言？"></a>Q: 怎麼讓來開會的人有暢所欲言？</h2><p>我也不是很清楚算不算做到，但心裡有一些平常在做的，幾點我的套路：</p><ol><li><code>以身作則</code>：我常說會議要準時，不要遲到，如果大家發現 Rick 無故遲到，請不用客氣ㄉㄧㄤ下去。<ul><li>除了會議，其他也是。看起來沒啥關係，只是想表達紀律，原則。</li></ul></li><li><code>承認自己能力有限</code>：讓大家知道，我們是一個 Team ，各有各的專長，遇到問題是可以一起分擔的。一個人能力很有限，但一個團隊可以很強大。</li><li><code>前中後的節奏</code>：<ul><li>討論前，主動丟出想法</li><li>討論中，一切都從白板開始，一開始就具象表達。</li><li>表達的時候，盡量用生活化的例子，或者用自己當例子，或者用現場的人當作故事角色，把大家串再一起。</li><li>用自己當例子是暴露自己的弱點，好惡，讓大家帶著輕鬆進入主題。</li></ul></li><li>平常營造討論的風氣，訓練大家表達的方法（我很強調這點）。<ul><li>討論的結果要可以具象化 (文件)、結構化 (還是文件)、之後可以依循 (又是文件)。</li></ul></li><li>大家對於討論有具體的內容，有一致的表達方法，下一個 run 就會有更具體的討論，加上前面 3) 建立的連線，4) 的具體內容 2) 弱化權力角色，1) 有紀律的團隊 … 也更容易暢所欲言… ?</li></ol><blockquote><p>更多參閱： <a href="/2020/08/01/Management/Expression-and-Communication/">表達與溝通的差異</a>、<a href="/2019/04/03/Management/Write-Document/">再談『為什麼寫文件？』</a></p></blockquote><hr><h1 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h1><ul><li><a href="/2019/04/05/About/Working-Backwards/">一個人的 Working Backwards</a></li><li><a href="/2019/03/30/Management/How-do-Manager-Keep-Learning/">管理者如何持續學習技術？</a></li><li><a href="/2021/12/19/Management/Protocol-to-Communication/">團隊溝通的通訊協議</a></li><li><a href="/2019/11/19/Management/Objectives-Key-Results-Executions/">有效定義目標與執行、落地</a></li><li><a href="/2020/08/01/Management/Expression-and-Communication/">表達與溝通的差異</a></li><li><a href="/2019/04/03/Management/Write-Document/">再談『為什麼寫文件？』</a></li><li><a href="/2022/09/10/About/Difficult-and-Complicate/">問題的難與雜</a></li><li><a href="https://www.facebook.com/rick.kyhwang/posts/pfbid0tWjKzm9BnagRqknGrnXfzA2DbqTCq1xCcFTdZjvRtkA2pu1rLSbpvfsYGFAe9Mtdl">人才發展策略地圖 (draft)</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;這段 &lt;a href=&quot;https://www.facebook.com/rick.kyhwang/posts/pfbid0gwDFvZ2RnZvTsFoo9bHgG5Hmfhs31953kjZa5MX3aj7jfrB6AsfaootqgcYM1Td7l&quot;&gt;筆記&lt;/a&gt; 是 2020 年聽 podcast 寫下的心得筆記、跟朋友討論的東西。這整個過程，也是我過去 &lt;code&gt;凝聚團隊共識&lt;/code&gt;、&lt;code&gt;人才養成&lt;/code&gt; 的實踐方法。&lt;/p&gt;</summary>
    
    
    
    <category term="經營管理" scheme="https://rickhw.github.io/categories/%E7%B6%93%E7%87%9F%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="溝通" scheme="https://rickhw.github.io/tags/%E6%BA%9D%E9%80%9A/"/>
    
    <category term="Awareness" scheme="https://rickhw.github.io/tags/Awareness/"/>
    
    <category term="主管" scheme="https://rickhw.github.io/tags/%E4%B8%BB%E7%AE%A1/"/>
    
    <category term="Consensus" scheme="https://rickhw.github.io/tags/Consensus/"/>
    
    <category term="人才養成策略" scheme="https://rickhw.github.io/tags/%E4%BA%BA%E6%89%8D%E9%A4%8A%E6%88%90%E7%AD%96%E7%95%A5/"/>
    
    <category term="團隊協作" scheme="https://rickhw.github.io/tags/%E5%9C%98%E9%9A%8A%E5%8D%94%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>新書上市 - 個人著作《SRE 實踐與開發平台指南》</title>
    <link href="https://rickhw.github.io/2023/07/17/About/2023-SRE-Practice-and-IDP/"/>
    <id>https://rickhw.github.io/2023/07/17/About/2023-SRE-Practice-and-IDP/</id>
    <published>2023-07-17T13:42:30.000Z</published>
    <updated>2025-06-27T12:21:44.293Z</updated>
    
    <content type="html"><![CDATA[<p>如果你希望買一本書，照著裡面說的步驟走，事情就搞定了，那這本書一定不適合你。</p><p>如果你希望買一本書，可以隨意翻閱，然後有種「啊！就是這樣啦！」，那這本書應該適合你。</p><p><img src="/images/About/2023-SRE-Practical-and-IDP/cover.jpg"></p><p>銷售通路：</p><ul><li><a href="https://www.tenlong.com.tw/products/9786263334908">天瓏書局</a></li><li><a href="https://www.books.com.tw/products/0010963275">博客來書店</a></li></ul><span id="more"></span><h2 id="方向規劃"><a href="#方向規劃" class="headerlink" title="方向規劃"></a>方向規劃</h2><p>一開始在構思這本書，是從去年演講 “<a href="/2022/05/10/About/2022-SREConf2022/">91APP 在 AWS 上的 SRE 實踐之路</a>“ 為主幹，搜集了很多資料，但是寫到一半發現，我開始在思考一些問題：</p><ol><li>希望讀者花 500 (假設) 得到什麼？有什麼啟發？</li><li>一本書要給讀者怎樣的內容，才值回票價？</li><li>這本書可以隨意翻閱？</li><li>讀者為啥要買我的書？</li><li>這本書十年後會變成桌墊？還是經典？</li></ol><p>後來想想，大筆一揮，砍掉很多東西，更多是重新整理最真實的經驗，分享背後的 QBQ。</p><p>問問我自己，拿起一本書的時候，希望得到什麼？</p><blockquote><p>不是希望得到答案，更多是獲得思考的機會，也就是啟發思考；不是要讀者都同意我的觀點，更多是因為我的觀點，獲得啟發與思考。</p></blockquote><p>這樣就達到我的目的了。</p><!--## 內容與讀者的距離：實際問題切入Google 的 SRE 本身閱讀起來，是有距離的，也就是上面提的問題，如果沒有一定規模，或者自建機房，大部分遇不到。書中九成九的內容，都是我自己親自經歷、決策、，其中有不少內容，曾經共事過的同事一定不陌生，甚至會有會心一笑的。## 減法原則：本來有規劃，但後來沒寫的，本來書內容規劃很多，後來我全砍了。。。 (下一本？本來要寫這些：- Coding, 談 OOP- 談 Design Pattern因為遇過不少傳統 OP 要轉 DevOps or SRE，但因為沒有 coding 技能，或者不想接觸 coding為什麼沒有寫？怕定位混亂--><h2 id="寫作方式"><a href="#寫作方式" class="headerlink" title="寫作方式"></a>寫作方式</h2><ul><li><code>寫作原則</code>: 以降低 SRE 的距離感為原則，所以以口語化、容易閱讀、讀起來沒壓力、拿起來，隨意翻閱都可以讀。</li><li><code>生活經驗</code>: 書中的概念，以生活的概念為原則，不管是技術或者方法，應該都可以在生活當中找到例子，也就是讀者透握自身的生活經歷，就可以理解裡面的想法。</li><li><code>持續閱讀</code>: 身邊有在閱讀的朋友應該算多，至少上個工作，有國寶級大師 Ruddy 老師，讓大家在 <code>閱讀</code> 這件事，讓同事們都很有養分。</li><li><code>章節關聯性</code>: 章節的安排，前半段盡量減少關聯性，後半段則有關聯性。</li></ul><h2 id="感謝"><a href="#感謝" class="headerlink" title="感謝"></a>感謝</h2><ul><li>業界推坑魔人 <code>正瑋</code> 引薦出版社，讓我嘗試跟編輯討論出版的方向。</li><li>感謝出版社 <code>Abby</code>、以及責任編輯 <code>Sammi</code> 的耐心與建議。</li><li>感謝推薦序的幾位好朋友：<code>Andrew</code>、<code>正瑋</code>、<code>Kim</code>、<code>小城</code>，在短短的時間之內看完，然後寫推薦序，真的是很感謝他們：<ul><li><a href="https://www.facebook.com/andrew0928/posts/pfbid0kTDAuqv2EA87KJyi1aQ63FAsTqBHeA3NB2Xm6BpBxbqRmMGuCRuEXM9btEWahb8Jl">Andrew Wu 的推薦序</a></li><li><a href="https://chengweichen.com/2023/07/rick-sre-book.html">正瑋 的推薦序</a></li><li><a href="https://www.facebook.com/kimkao.solid/posts/pfbid02KRokXvwxvcS4vdGjqEASF47Ard79AD1B7btjqRWoRY8y18rjD4J6hSGsgh65yNCpl">Kim Kao 的推薦序</a></li><li><a href="https://medium.com/smalltowntechblog/sre%E5%AF%A6%E8%B8%90%E8%88%87%E9%96%8B%E7%99%BC%E5%B9%B3%E5%8F%B0%E6%8C%87%E5%8D%97-%E6%8E%A8%E8%96%A6%E5%BA%8F-%E4%B8%8D%E7%94%A8n%E5%B9%B4%E7%9A%84%E5%BE%9E%E6%A5%AD%E7%B6%93%E9%A9%97-%E5%8F%AA%E9%9C%80%E9%80%8F%E9%81%8E%E6%9C%AC%E6%9B%B8-%E5%8D%B3%E5%8F%AF%E5%9C%A8%E7%B6%AD%E9%81%8B%E8%B7%AF%E4%B8%8A%E6%92%A5%E9%9B%B2%E8%A6%8B%E6%97%A5-9e9d9a4b1c9">小城的推薦序</a></li></ul></li><li>感謝前東家 91APP 過去那麼多年舞台以及養分</li><li>感謝一起成長的團隊 - <code>91APP Infra Team (原 RD5)</code>，從零到一、從一到十，一路上不離不棄，不斷地鞭策，伴我成長</li></ul><h2 id="書中彩蛋"><a href="#書中彩蛋" class="headerlink" title="書中彩蛋"></a>書中彩蛋</h2><p>跟我共事過的同事都知道，我很重視閱讀文件這件事情，凡事都會要求先看過文件。這樣要求的同時，我也會要求自己把文件寫清楚，Infra Team 裡起草規範、制度、規格、Guideline 寫最多的一定是我，而且就是白紙黑字。</p><p>不過我很清楚，大部分的同仁不會去細看這些東西，所以我曾經在規格文件中，埋藏彩蛋，讓細心的同事有驚喜，如下圖 (<a href="https://www.facebook.com/rick.kyhwang/posts/pfbid031dXbsA7VNKFDDnQJAUQv7huPWAcQKJnbnMS7EadVvqKfT8wXHGVTEhytmBjhipvNl">原始連結</a>)</p><p><img src="/images/About/2023-SRE-Practical-and-IDP/happy-water.png"></p><p>書中也有這樣的彩蛋，不過要稍微動一點腦筋。。。找到歡迎私訊我，限量兩本書送給先找到的朋友 XD</p><h2 id="Q-and-A"><a href="#Q-and-A" class="headerlink" title="Q and A"></a>Q and A</h2><h3 id="Q-電子書的通路平台有哪些？"><a href="#Q-電子書的通路平台有哪些？" class="headerlink" title="Q: 電子書的通路平台有哪些？"></a>Q: 電子書的通路平台有哪些？</h3><blockquote><p>目前出版社回覆有合作的電子平台如下：博碩有長期合作的十大電子書平台 (博客來、讀墨 (Readmoo)、Pubu、Kobo樂天、Googleplay、凌網 (Hyread)、UDN (聯合線上)、讀冊生活、台灣漫讀 (Bookwalker)、mybook)</p></blockquote><h3 id="Q-電子書上市時間？"><a href="#Q-電子書上市時間？" class="headerlink" title="Q: 電子書上市時間？"></a>Q: 電子書上市時間？</h3><blockquote><p>出版社回覆：實體書上架後兩個月，實體書 08&#x2F;01 上架。</p></blockquote><h3 id="Q-有新書發表會或實體活動嗎？"><a href="#Q-有新書發表會或實體活動嗎？" class="headerlink" title="Q: 有新書發表會或實體活動嗎？"></a>Q: 有新書發表會或實體活動嗎？</h3><ul><li>2023&#x2F;07&#x2F;22: 目前 DevOps Taiwan 協助安排，活動報名處 <a href="https://devops.kktix.cc/events/meetup-54-rick-sre-book">KKtix</a>，其他邀約正在協調中。</li><li>2023&#x2F;08&#x2F;01 Updated:<ul><li>(已經結束) <a href="https://devops.kktix.cc/events/meetup-54-rick-sre-book">08&#x2F;19 (六) 1400-1630: 天瓏書局 Coding Space, DevOps Taiwan 主辦</a></li><li>(已經結束) <a href="https://agilecommtw.kktix.cc/events/sre-book">08&#x2F;26 (六) 1400-1700: 逸空間 (Yi-Spaces), Agile Taipei 主辦</a></li></ul></li></ul><h3 id="Q-寫作過程有用到-ChatGPT？或者參考？"><a href="#Q-寫作過程有用到-ChatGPT？或者參考？" class="headerlink" title="Q: 寫作過程有用到 ChatGPT？或者參考？"></a>Q: 寫作過程有用到 ChatGPT？或者參考？</h3><blockquote><p>只有整理 IDP 時候參考一下其他人寫的想法，然後融入自己的經驗。用 ChatGPT 倒是沒有。主要是整件事情我都有想過，問題是，我的腦袋裡沒有 ChatGPT … 所以就算問 ChatGPT，答案也不是我要的。</p></blockquote><hr><h2 id="紀錄"><a href="#紀錄" class="headerlink" title="紀錄"></a>紀錄</h2><h3 id="06-x2F-18-六-首度揭露資訊"><a href="#06-x2F-18-六-首度揭露資訊" class="headerlink" title="06&#x2F;18 (六) 首度揭露資訊"></a>06&#x2F;18 (六) 首度揭露資訊</h3><p>在 <a href="/2023/05/23/About/2023-Software-Test-Practice/">軟體測試實務 新書發表會</a> 現場首度揭露資訊，事後在 FB 發布的訊息 <a href="https://www.facebook.com/rick.kyhwang/posts/pfbid02GyqUw7GevVSMeJYMzp7ixSfQ5cJUJWNFKT8gey2LCH8rVQhkeQrjs4Xni397qxmBl">link</a></p><p><img src="/images/About/2023-SRE-Practical-and-IDP/20230618_6.png"></p><h3 id="07-x2F-17-一-公開預購訊息"><a href="#07-x2F-17-一-公開預購訊息" class="headerlink" title="07&#x2F;17 (一) 公開預購訊息"></a>07&#x2F;17 (一) 公開預購訊息</h3><p>個人 FB 曝光訊息: <a href="https://www.facebook.com/rick.kyhwang/posts/pfbid02XRUh3a63Wq9Lvkz4oF71k1DWUBhHqjCKgcycdgscRxDZD2JpxNrUMojcVAF1XuRJl">link</a></p><p><img src="/images/About/2023-SRE-Practical-and-IDP/20230717_1_open.png"></p><p>天龍書局的 Banner</p><p><img src="/images/About/2023-SRE-Practical-and-IDP/20230717_tenlong_banner.jpg"></p><h3 id="07-x2F-17-三-開放預購第三天，週銷售-Top1"><a href="#07-x2F-17-三-開放預購第三天，週銷售-Top1" class="headerlink" title="07&#x2F;17 (三) 開放預購第三天，週銷售 Top1"></a>07&#x2F;17 (三) 開放預購第三天，週銷售 Top1</h3><p><img src="/images/About/2023-SRE-Practical-and-IDP/20230719_3-weekly-top1.jpg"></p><h3 id="07-x2F-21-五-開放預購第五天，月銷售-Top1"><a href="#07-x2F-21-五-開放預購第五天，月銷售-Top1" class="headerlink" title="07&#x2F;21 (五) 開放預購第五天，月銷售 Top1"></a>07&#x2F;21 (五) 開放預購第五天，月銷售 Top1</h3><p><img src="/images/About/2023-SRE-Practical-and-IDP/20230721_5-monthly-top1.jpeg"></p><p>Page View: FB like 500++</p><p><img src="/images/About/2023-SRE-Practical-and-IDP/20230721_5-pageview.png"></p><h3 id="2024-x2F-01-x2F-02-天瓏書局-2023-百大"><a href="#2024-x2F-01-x2F-02-天瓏書局-2023-百大" class="headerlink" title="2024&#x2F;01&#x2F;02 天瓏書局 2023 百大"></a>2024&#x2F;01&#x2F;02 天瓏書局 2023 百大</h3><p><a href="https://www.tenlong.com.tw/events/2023-top100">https://www.tenlong.com.tw/events/2023-top100</a></p><p><img src="/images/About/2023-SRE-Practical-and-IDP/20240102-1.png"></p><p><img src="/images/About/2023-SRE-Practical-and-IDP/20240102-2.png"></p><hr><h2 id="書友見面會"><a href="#書友見面會" class="headerlink" title="書友見面會"></a>書友見面會</h2><p>簡報:</p><iframe src="https://www.slideshare.net/slideshow/embed_code/key/4CmibR0EfoTgjf?startSlide=1" width="597" height="486" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px;max-width: 100%;" allowfullscreen></iframe><div style="margin-bottom:5px"><strong><a href="https://www.slideshare.net/rickhwang/2023-08-sre" title="2023 08 - SRE 實踐與開發平台指南 - 書友見面會" target="_blank">2023 08 - SRE 實踐與開發平台指南 - 書友見面會</a></strong> from <strong><a href="https://www.slideshare.net/rickhwang" target="_blank">Rick Hwang</a></strong></div><p>活動照片：</p><h3 id="天瓏書局"><a href="#天瓏書局" class="headerlink" title="天瓏書局"></a>天瓏書局</h3><ul><li>照片：<a href="https://www.facebook.com/media/set/?set=a.10219080102392862&type=3">20230819_6 - SRE 書友見面會 (天瓏書局)</a></li><li>現場書友的心得筆記 - <a href="https://www.facebook.com/permalink.php?story_fbid=pfbid02wDp4A97zux4NwUHApfS5JQYv256smD59YwYTf6Q41vwBegbuqtqb1HRRjeAptE4Kl&id=100068893800768">Anna Su Notes</a></li></ul><p><img src="/images/About/2023-SRE-Practical-and-IDP/20230819_6-1.JPG"><br><img src="/images/About/2023-SRE-Practical-and-IDP/20230819_6-2.JPG"><br><img src="/images/About/2023-SRE-Practical-and-IDP/20230819_6-3.JPG"><br><img src="/images/About/2023-SRE-Practical-and-IDP/20230819_6-4.JPG"><br><img src="/images/About/2023-SRE-Practical-and-IDP/20230819_6-5.JPG"></p><h3 id="逸空間"><a href="#逸空間" class="headerlink" title="逸空間"></a>逸空間</h3><ul><li>照片：<a href="https://www.facebook.com/media/set/?vanity=rick.kyhwang&set=a.10219114701337814">20230823_6 - SRE 書友見面會 (逸空間, Agile Taipei)</a></li></ul><p><img src="/images/About/2023-SRE-Practical-and-IDP/20230826_6-1.JPG"><br><img src="/images/About/2023-SRE-Practical-and-IDP/20230826_6-2.JPG"><br><img src="/images/About/2023-SRE-Practical-and-IDP/20230826_6-3.JPG"><br><img src="/images/About/2023-SRE-Practical-and-IDP/20230826_6-4.JPG"><br><img src="/images/About/2023-SRE-Practical-and-IDP/20230826_6-5.JPG"></p><hr><h1 id="其他資訊"><a href="#其他資訊" class="headerlink" title="其他資訊"></a>其他資訊</h1><ul><li>iTHome - <a href="https://www.ithome.com.tw/article/157902">星期五不應該部署？</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;如果你希望買一本書，照著裡面說的步驟走，事情就搞定了，那這本書一定不適合你。&lt;/p&gt;
&lt;p&gt;如果你希望買一本書，可以隨意翻閱，然後有種「啊！就是這樣啦！」，那這本書應該適合你。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/About/2023-SRE-Practical-and-IDP/cover.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;銷售通路：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.tenlong.com.tw/products/9786263334908&quot;&gt;天瓏書局&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.books.com.tw/products/0010963275&quot;&gt;博客來書店&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="About" scheme="https://rickhw.github.io/categories/About/"/>
    
    
    <category term="SRE" scheme="https://rickhw.github.io/tags/SRE/"/>
    
    <category term="Books" scheme="https://rickhw.github.io/tags/Books/"/>
    
    <category term="Platform Engineering" scheme="https://rickhw.github.io/tags/Platform-Engineering/"/>
    
    <category term="Internal Developer Platform" scheme="https://rickhw.github.io/tags/Internal-Developer-Platform/"/>
    
  </entry>
  
</feed>
